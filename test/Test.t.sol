// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.17;
pragma abicoder v2;

import "forge-std/Test.sol";
import "./Strings.sol";

interface IMulticall {
    function multicall(uint256 deadline,bytes[] calldata data) external returns (bytes[] memory);
}

library TickMath {
    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128.
    int24 internal constant MIN_TICK = -887272;
    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128 - 1.
    int24 internal constant MAX_TICK = -MIN_TICK;
    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick - equivalent to getSqrtRatioAtTick(MIN_TICK).
    uint160 internal constant MIN_SQRT_RATIO = 4295128739;
    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick - equivalent to getSqrtRatioAtTick(MAX_TICK).
    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;

    error TickOutOfBounds();
    error PriceOutOfBounds();
    error InvalidCPTick();

    /// @notice Calculates sqrt(1.0001^tick) * 2^96.
    /// @dev Throws if |tick| > max tick.
    /// @param tick The input tick for the above formula.
    /// @return sqrtPriceX96 Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
    /// at the given tick.
    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
        if (absTick > uint256(uint24(MAX_TICK))) revert TickOutOfBounds();
        unchecked {
            uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;

            if (tick > 0) ratio = type(uint256).max / ratio;
            // This divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
            // We then downcast because we know the result always fits within 160 bits due to our tick input constraint.
            // We round up in the division so getTickAtSqrtRatio of the output price is always consistent.
            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
        }
    }

    function validatePrice(uint160 price, uint24 tickSpacing) internal pure {
        if (price < MIN_SQRT_RATIO || price >= MAX_SQRT_RATIO) revert PriceOutOfBounds();
        int24 tick = getTickAtSqrtRatio(price);
        if ((tick) % int24(tickSpacing) != 0) revert InvalidCPTick();
    }

    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio.
    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may
    /// ever return.
    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96.
    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio.
    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
        // Second inequality must be < because the price can never reach the price at the max tick.
        if (sqrtPriceX96 < MIN_SQRT_RATIO || sqrtPriceX96 >= MAX_SQRT_RATIO) revert PriceOutOfBounds();
        uint256 ratio = uint256(sqrtPriceX96) << 32;

        uint256 r = ratio;
        uint256 msb;

        assembly {
            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(5, gt(r, 0xFFFFFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(4, gt(r, 0xFFFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(3, gt(r, 0xFF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(2, gt(r, 0xF))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := shl(1, gt(r, 0x3))
            msb := or(msb, f)
            r := shr(f, r)
        }
        assembly {
            let f := gt(r, 0x1)
            msb := or(msb, f)
        }
        unchecked {
            if (msb >= 128) r = ratio >> (msb - 127);
            else r = ratio << (127 - msb);

            int256 log_2 = (int256(msb) - 128) << 64;

            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(63, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(62, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(61, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(60, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(59, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(58, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(57, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(56, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(55, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(54, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(53, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(52, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(51, f))
                r := shr(f, r)
            }
            assembly {
                r := shr(127, mul(r, r))
                let f := shr(128, r)
                log_2 := or(log_2, shl(50, f))
            }

            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number.

            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);

            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
        }
    }
}

struct Tick {
    int24 previousTick;
    int24 nextTick;
    uint128 liquidity;
    uint256 feeGrowthOutside0; // Per unit of liquidity.
    uint256 feeGrowthOutside1;
    uint160 secondsGrowthOutside;
}

interface ICLPManager {

    function mint(
        address pool,
        int24 lowerOld,
        int24 lower,
        int24 upperOld,
        int24 upper,
        uint128 amount0Desired,
        uint128 amount1Desired,
        bool native,
        uint256 minLiquidity,
        uint256 positionId
    ) external payable returns (uint256 _positionId);
}

interface ICLP {
    function reserve0() external returns (uint128);
    function reserve1() external returns (uint128);
    function limitOrderReserve0() external returns (uint256);
    function limitOrderReserve1() external returns (uint256);
    function tickCount() external returns (uint256);
    function swap(bytes memory data, bytes calldata path) external returns (uint256 amountOut, uint256 amountIn);
    function liquidity() external returns (uint128);
    function nearestTick() external returns (int24);
    function ticks(int24 tick) external returns (Tick memory);
    function getPriceAndNearestTicks() external returns (uint160 _price, int24 _nearestTick);
}


struct User {
    string name;
    address addr;
}

interface IPoolDeployer {
    function poolsCount(address token0, address token1) external returns (uint256 count);
    function getPools(address token0, address token1) external returns (address[] memory pairPools);
}

contract DfynBugHunt is Test {
    using Strings for string;

    int24 MIN_TICK = -887272;
    int24 MAX_TICK =  887272;
    int24 tickSpacing = 10;


    address alice = 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266;
    address bob = 0x70997970C51812dc3A010C7d01b50e0d17dc79C8;
    address charlie = 0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC;

    IMulticall multicall = IMulticall(0x47b7169c7d722C65eC1545f0a14770c3C8acBe43);

    ICLP pool1 = ICLP(0x276F8cF73EDeb658c1fce55AB0E958Fa74948D32);
    /*
     * A list of other pools
     *
     *   0x0d4757dd7E38C3976f7e5B0F1c99b9D2f03Fa97c
     *   0x5B3e5C94a5db103007f778db7bF952FAd497F347
     *   0xa7AeBE0B79abb4Ccb89702A6245b23657fA824c4
     *   0x832e29B108cF1ccBb47b4DA506B0E3EBf727A88D   // Feb-06-2023 08:47:33 AM +UTC
     */

    ICLP pool2 = ICLP(0x832e29B108cF1ccBb47b4DA506B0E3EBf727A88D);

    IPoolDeployer poolDeployer = IPoolDeployer(0x20F200c65bDD173Df64a528e28F77F06ebDE61D9);
    address TUSDC = 0x191B957b6D591e07C49eF8C1c837823F72DAeE01;
    address TMON = 0xb8D19e5B2Afb8e919ab3F5a3f221b80fD772fCD4;



    constructor() {
    }


    function setUp() public {
        vm.label(0x59d7b3F047F0E1B5bad7424C52E0AF5736800769, "User");
        vm.label(0x47b7169c7d722C65eC1545f0a14770c3C8acBe43, "Multicall");
        vm.label(address(pool1), "ConcentratedLiquidityPool TMON/TUSDC");
        vm.label(0xCBdf60E9985C8cB70D360cBe8838758D7554EDcb, "Vault");
        vm.label(TMON, "TMON");
        vm.label(TUSDC, "TUSDC");
        vm.label(0x7b50F6290391D97eAE03C7bD04200e5DdC412305, "SwapExcecuter");
    }

    function notestMulticall() public {
        address user = 0x59d7b3F047F0E1B5bad7424C52E0AF5736800769;

        bytes[] memory data = new bytes[](2);
        data[0] = hex"01c6adc3000000000000000000000000b8d19e5b2afb8e919ab3f5a3f221b80fd772fcd4000000000000000000000000000000000000000000028c1e34ce4e6075ffc3cf";
        data[1] = hex"b8fd05a50000000000000000000000000000000000000000000000000000000000000001000000000000000000000000b8d19e5b2afb8e919ab3f5a3f221b80fd772fcd4000000000000000000000000191b957b6d591e07c49ef8c1c837823f72daee0100000000000000000000000059d7b3f047f0e1b5bad7424c52e0af573680076900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000021e9224efbf9f78c8c7a5";


        vm.createSelectFork("https://polygon-mainnet.g.alchemy.com/v2/r6TvHRp7EA7lD3EbzLBKYJdsQeE9lpc1", 38911468);
        vm.startPrank(user);
        multicall.multicall(1675549119, data);
        vm.stopPrank();

    }

    function notestLiquidityUnderflowAtBlockHeight38870311() public {
        address user = 0xDf9657BB784A13cb5C67a43C4BebCcf8C84F377c;
        vm.label(0x59d7b3F047F0E1B5bad7424C52E0AF5736800769, "User");
        vm.label(0x47b7169c7d722C65eC1545f0a14770c3C8acBe43, "Multicall");
        vm.label(address(pool1), "ConcentratedLiquidityPool TMON/TUSDC");
        vm.label(0xCBdf60E9985C8cB70D360cBe8838758D7554EDcb, "Vault");
        vm.label(0xb8D19e5B2Afb8e919ab3F5a3f221b80fD772fCD4, "TMON");
        vm.label(0x191B957b6D591e07C49eF8C1c837823F72DAeE01, "TUSDC");
        vm.label(0x7b50F6290391D97eAE03C7bD04200e5DdC412305, "SwapExcecuter");
        vm.label(0xd52A1a185A4704339d57edd59CF7282fDBa5822c, "Ticks");

        bytes[] memory data = new bytes[](4);
        data[0] = hex"01c6adc3000000000000000000000000b8d19e5b2afb8e919ab3f5a3f221b80fd772fcd4000000000000000000000000000000000000000000001926609cc2ef7fe60000";
        data[1] = hex"669e416c0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000df9657bb784a13cb5c67a43c4bebccf8c84f377c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009d5a51e7472db4f7500000000000000000000000000000000000000000000000000000000000000003cb8d19e5b2afb8e919ab3f5a3f221b80fd772fcd4779a94f3d040b3aecc506b887c9c9e331d51dd7f191b957b6d591e07c49ef8c1c837823f72daee0100000000";
        data[2] = hex"01c6adc3000000000000000000000000b8d19e5b2afb8e919ab3f5a3f221b80fd772fcd4000000000000000000000000000000000000000000000152dca9ef4ff9420000";
        data[3] = hex"b8fd05a50000000000000000000000000000000000000000000000000000000000000001000000000000000000000000b8d19e5b2afb8e919ab3f5a3f221b80fd772fcd4000000000000000000000000191b957b6d591e07c49ef8c1c837823f72daee01000000000000000000000000df9657bb784a13cb5c67a43c4bebccf8c84f377c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009cc82e92932a7324e4";

        // We send the transaction using block before (because that's the state at the end of that block)
        vm.createSelectFork("https://polygon-mainnet.g.alchemy.com/v2/r6TvHRp7EA7lD3EbzLBKYJdsQeE9lpc1", 38870310);
        vm.startPrank(user);
        multicall.multicall(1675457441, data);
        logClpStats(pool1);
        vm.stopPrank();

    }


    function notestLiquidityUnderflowAtBlockHeight38862741() public {
        address user = 0xb97987D9B528fEf604ef129D8f9B7c84764766b8;
        vm.label(0x59d7b3F047F0E1B5bad7424C52E0AF5736800769, "User");
        vm.label(0x47b7169c7d722C65eC1545f0a14770c3C8acBe43, "Multicall");
        vm.label(address(pool1), "ConcentratedLiquidityPool TMON/TUSDC");
        vm.label(0xCBdf60E9985C8cB70D360cBe8838758D7554EDcb, "Vault");
        vm.label(0xb8D19e5B2Afb8e919ab3F5a3f221b80fD772fCD4, "TMON");
        vm.label(0x191B957b6D591e07C49eF8C1c837823F72DAeE01, "TUSDC");
        vm.label(0x7b50F6290391D97eAE03C7bD04200e5DdC412305, "SwapExcecuter");
        vm.label(0xd52A1a185A4704339d57edd59CF7282fDBa5822c, "Ticks");

        bytes[] memory data = new bytes[](4);
        data[0] = hex"01c6adc3000000000000000000000000b8d19e5b2afb8e919ab3f5a3f221b80fd772fcd400000000000000000000000000000000000000000000d3c21bcecceda1000000";
        data[1] = hex"b8fd05a50000000000000000000000000000000000000000000000000000000000000001000000000000000000000000b8d19e5b2afb8e919ab3f5a3f221b80fd772fcd4000000000000000000000000191b957b6d591e07c49ef8c1c837823f72daee01000000000000000000000000403850ee9134bc7131d9319d00d66476a5355cff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000039aa239893c1008549";

        // We send the transaction using block before (because that's the state at the end of that block)
        vm.createSelectFork("https://polygon-mainnet.g.alchemy.com/v2/r6TvHRp7EA7lD3EbzLBKYJdsQeE9lpc1", 38862740);
        vm.startPrank(user);
        multicall.multicall(1675440389, data);
        logClpStats(pool1);
        vm.stopPrank();

    }

    function notestBlock_38159348() public {
        vm.createSelectFork("https://polygon-mainnet.g.alchemy.com/v2/r6TvHRp7EA7lD3EbzLBKYJdsQeE9lpc1", 38159348);
        logClpStats(pool1);
        invariantHolds(pool1, true, 10);

    }

    function notestPools() public {
        //console.log("poolsCount = %s", poolDeployer.poolsCount(TUSDC, TMON));
    }

    function testLocalInvariant() public {
        // uint256  38150000;   // original success
        // uint256  38862740;   // original failure

        // uint256 lastSuccess = 38159347;
        // uint256 lastFail    = 38159348;

        uint256 mid = 39224600;  // (lastSuccess + lastFail)/2;

        console.log("--- Trying %s ---", mid);
        vm.createSelectFork("https://polygon-mainnet.g.alchemy.com/v2/r6TvHRp7EA7lD3EbzLBKYJdsQeE9lpc1", mid);
        invariantHolds(pool2,true,  10);
        invariantHolds(pool2,false, 10);
    }

    function invariantHolds(ICLP clp, bool forward, uint256 n) internal returns (bool) {
        int256 total = int256(uint256(clp.liquidity()));
        Tick memory current;
        int24 tick = clp.nearestTick();
        current = clp.ticks(tick);
        bool isEven;
        bool doAdd;
        console.log("---------------");
        console.log("%s.liquidity = %s", vm.toString(tick), current.liquidity);
        console.log("%s from %s starting with %s", (forward ? "fowards" : "backwards"), vm.toString(tick), vm.toString(total));
        for (uint256 i=0; i < n; i++) {
            int24 newTick = forward ? current.nextTick : current.previousTick;
            int256 oldTotal = total;
            current = clp.ticks(newTick);
            isEven = (newTick % (2*tickSpacing) == 0);
            doAdd = forward? isEven : !isEven;
            int256 liq = int256(uint256(current.liquidity));
            if (doAdd) { total += liq; } else { total -= liq;}
            console.log("%s.liquidity = %s", vm.toString(newTick), vm.toString(liq));
            console.log("%s: %s = %s", vm.toString(newTick), vm.toString(oldTotal).concat(doAdd ? " + " : " - ").concat(vm.toString(liq)), vm.toString(total));
            if (total < 0){
                console.log("*** Invariant violated! ***");
                return false;
            }
        }
        return true;
    }


    function notestInvariant() public {
        vm.createSelectFork("https://polygon-mainnet.g.alchemy.com/v2/r6TvHRp7EA7lD3EbzLBKYJdsQeE9lpc1", 38862741);


        uint256 count = pool1.tickCount() - 2; // don't include MIN_TICK and MAX_TICK
        console.log("tick count = %s", count);
        Tick[] memory ticks = new Tick[](count);
        // Go all the way back to the earliest tick
        int24 currentTick = pool1.nearestTick();
        Tick memory current = pool1.ticks(currentTick);

        // }
        while (current.previousTick != MIN_TICK || (currentTick < 0 && current.previousTick == 0)) {
            currentTick = current.previousTick;
            current = pool1.ticks(currentTick);
        }


        // Start filling the array
        for (uint256 i = 0; i < count; i++) {
            ticks[i] = current;
            current = pool1.ticks(current.nextTick);
        }

        // test the invariant
        int256 total = 0;
        for (uint256 i = 0; i < count; i++) {

            int24 tickIndex;
            if (i < count - 1) {
              tickIndex = ticks[i+1].previousTick;
            } else {
              tickIndex = ticks[count-2].nextTick;
            }

            int256 liq = int256(uint256(ticks[i].liquidity));
            if (tickIndex % (2*tickSpacing) == 0) {
                total += liq;
            } else {
                total -= liq;
            }
            console.logInt(tickIndex);
            console.log("TOTAL");
            console.logInt(total);
            console.log("");
            if (total < 0) {
                console.log("!!!! Invariant violated! !!!!");
                console.logInt(tickIndex);
            }

        }
        logClpStats(pool1);

        //console.logInt(current.nextTick);

    }

    function notestReservesAtBlockHeights() public {
        uint256 start  = 38862740;
        uint256 finish = 38862741;

        uint256 inc  = (finish - start)/10;
        for (uint256 h = start; h <= finish; h+= inc > 0 ? inc : 1) {
            console.log("Height: %s", h);
            vm.createSelectFork("https://polygon-mainnet.g.alchemy.com/v2/r6TvHRp7EA7lD3EbzLBKYJdsQeE9lpc1", h);
            logClpStats(pool1);
        }
    }

    function notestInvariantAtBlockHeights() public {
        uint256 start  = 38862736;
        uint256 finish = 38862753;

        // uint256 start  = 0x25079d4;
        // uint256 finish = 0x25079d4;


        uint256 inc  = (finish - start)/10;
        for (uint256 h = start; h <= finish; h+= (inc > 0 ? inc : 1)) {
            console.log("Height: %s", h);
            vm.createSelectFork("https://polygon-mainnet.g.alchemy.com/v2/r6TvHRp7EA7lD3EbzLBKYJdsQeE9lpc1", h);
            logClpStats(pool1);
        }
    }

    function notestCLPManager() public {
        ICLPManager(0xE664A5DBa489b55144B30b9260C09301AAbFa14e).mint(
            0x276F8cF73EDeb658c1fce55AB0E958Fa74948D32,
            -887272,
            -887260,
            92110,
            887270,
            4999999999999999999,
            5888739410763269492,
            true,
            0,
            0
        );
    }

    function logClpStats(ICLP _clp) internal {
//        int24 _lowerTick = clp.nearestTick();

        uint128 _liquidity = _clp.liquidity();
        (uint160 price, int24 nearestTick) = _clp.getPriceAndNearestTicks();
        int24 priceAtTick = TickMath.getTickAtSqrtRatio(price);

        console.log("CLP {");
        console.log("  reserve0           = %s", _clp.reserve0());
        console.log("  reserve1           = %s", _clp.reserve1());
        console.log("  limitOrderReserve0 = %s", _clp.limitOrderReserve0());
        console.log("  limitOrderReserve1 = %s", _clp.limitOrderReserve1());
        console.log("  nearestTick        = %s", vm.toString(nearestTick));
        console.log("  priceAtTick        = %s", vm.toString(priceAtTick));
        console.log("  liquidity          = %s", _liquidity);
        console.log("}");

    }

    // function logClpStats() internal {
    //     int24 _lowerTick = clp.nearestTick();
    //     (,int24 _upperTick,,,,) = clp.ticks(_lowerTick);
    //     (,,uint128 lowerTickLiquidity,,,) = clp.ticks(_lowerTick);
    //     (,,uint128 upperTickLiquidity,,,) = clp.ticks(_upperTick);
    //     int24 tickSpacing = 10; // learned this from looking at `forge` traces
    //     uint24 uLowerTick = uint24(_lowerTick < 0 ? - _lowerTick : _lowerTick);
    //     bool lowerTickEven = (_lowerTick / int24(tickSpacing)) % 2 == 0;
    //     uint24 uUpperTick = uint24(_upperTick < 0 ? - _upperTick : _upperTick);
    //     bool upperTickOdd = (_upperTick / int24(tickSpacing)) % 2 == 1;

    //     (,,uint128 tick1670Liquidity,,,) = clp.ticks(1670);


    //     uint128 _liquidity = clp.liquidity();

    //     console.log("CLP {");
    //     console.log("  reserve0           = %s", clp.reserve0());
    //     console.log("  reserve1           = %s", clp.reserve1());
    //     console.log("  limitOrderReserve0 = %s", clp.limitOrderReserve0());
    //     console.log("  limitOrderReserve1 = %s", clp.limitOrderReserve1());
    //     console.log("  liquidity          = %s", _liquidity);
    //     console.log("  lowerTick          = %s%s", (_lowerTick < 0 ? "-" : ""), uLowerTick);
    //     console.log("  lowerTickLiquidity = %s", lowerTickLiquidity);
    //     console.log("  upperTick          = %s%s", (_upperTick < 0 ? "-" : ""), uUpperTick);
    //     console.log("  upperTickLiquidity = %s", upperTickLiquidity);

    //     // console.log("  1670Liquidity      = %s", tick1680Liquidity);


    //     console.log("");
    //     console.log("  invariant     = %s", (upperTickOdd ? upperTickLiquidity <= _liquidity : true) && (lowerTickEven ? lowerTickLiquidity <= _liquidity : true));
    //     console.log("}");
    // }
}