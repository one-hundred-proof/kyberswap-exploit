// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "helpers/Pretty.sol";
import "helpers/BitUtils.sol";


import {IERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "src/interfaces/IPool.sol";
import "src/interfaces/periphery/IRouter.sol";
import "src/interfaces/periphery/IBasePositionManager.sol";
import "src/libraries/TickMath.sol";
import "src/libraries/QtyDeltaMath.sol";

contract KyberswapTest is Test {

    using stdStorage for StdStorage;

    using Pretty for uint256;
    using Pretty for int256;
    using Pretty for uint128;
    using Pretty for int128;
    using Pretty for uint8;
    string API_ENDPOINT;

    address WETH_addr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address wstETH_addr = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    IERC20 wstETH = IERC20(wstETH_addr);
    IERC20 WETH = IERC20(WETH_addr);

    IPool wstETH_ETH = IPool(0xeBfE63Ba0264aD639B3C41d2bfE1aD708F683bc8);

    IRouter router = IRouter(0xC1e7dFE73E1598E3910EF4C7845B68A9Ab6F4c83);
    IBasePositionManager positionManager = IBasePositionManager(0x2B1c7b41f6A8F2b2bc45C3233a5d5FB3cD6dC9A8);

    bytes32 SQRTP_INDEX = bytes32(uint256(3));
    bytes32 BASEL_INDEX = bytes32(uint256(4));

    function setUp() public {
        API_ENDPOINT = vm.envString("EVMNET_FORK_URL");
        // Optionally pass a second argument to choose the block number
        vm.createSelectFork(API_ENDPOINT, 17029900);
        deal(wstETH_addr, address(this), 1_000_000e18);
        deal(WETH_addr, address(this), 1_000_000e18);
        wstETH.approve(address(router), type(uint256).max);
        WETH.approve(address(router), type(uint256).max);
        wstETH.approve(address(positionManager), type(uint256).max);
        WETH.approve(address(positionManager), type(uint256).max);
    }

    function notestBidDownPrice() public view {
        uint160 upperSqrtP = getSqrtP();
        uint160 lowerSqrtP = TickMath.getSqrtRatioAtTick(0);
        int256 liqRequired = QtyDeltaMath.calcRequiredQty0(lowerSqrtP, upperSqrtP, getLiquidity(), true);
        console.log("liqRequired = %s", liqRequired.pretty());
    }

    function testDoubleCount() public {
        uint256 snapshotId = vm.snapshot();
        uint128 liquidityWithDouble = doTestDoubleCount(true);
        vm.revertTo(snapshotId);
        console.log("==================================================");
        uint128 liquidityWithoutDouble = doTestDoubleCount(false);
        console.log("==================================================");
        console.log("Liquidity double counted = %s", (liquidityWithDouble - liquidityWithoutDouble).pretty());
    }

    function doTestDoubleCount(bool doDoubleCount) internal returns (uint128) {
        setLiquidity(2**96*uint128(11000)/10000);

        int24 nearestCurrentTick = getNearestCurrentTick();
        logTick(getCurrentTick());
        logTick(nearestCurrentTick);
        int24 tickOnBoundary = nearestCurrentTick;
        console.log("tickOnBoundary = %s", vm.toString(tickOnBoundary));
        setCurrentTick(nearestCurrentTick);
        uint160 price = TickMath.getSqrtRatioAtTick(getCurrentTick());
        setSqrtP(price);
        console.log("--- Initial pool state ---");
        logPoolState();

        if (doDoubleCount) {
          console.log("--- Swap backwards without moving price ---");
          IRouter.ExactInputSingleParams memory backwardsParams = getExactInputSingleParams(1, true);
          router.swapExactInputSingle(backwardsParams);
          logPoolState();
        }

        ////////////////

        console.log("--- Add liquidity to tick %s ---", vm.toString(tickOnBoundary));
        nearestCurrentTick = getNearestCurrentTick();
        (int24 prev, int24 next) = wstETH_ETH.initializedTicks(nearestCurrentTick);
        console.log("%s < %s < %s", vm.toString(prev), vm.toString(nearestCurrentTick), vm.toString(next));

        int24[2] memory ticksPrevious;
        ticksPrevious[0] = nearestCurrentTick;
        ticksPrevious[1] = nearestCurrentTick;

        console.log("Adding liquidity to (%s , %s)", vm.toString(tickOnBoundary), vm.toString(tickOnBoundary + 1));
        IBasePositionManager.MintParams memory mintParams =
          IBasePositionManager.MintParams(
            wstETH_addr,
            WETH_addr,
            wstETH_ETH.swapFeeUnits(),
            tickOnBoundary,
            tickOnBoundary + 1,
            ticksPrevious,
            40_000e18,
            1_000_000e18,
            0,
            0,
            address(this),
            block.timestamp + 86400
          );
          (,uint128 liqAdded,,) = positionManager.mint(mintParams);
          console.log("Liquidity added to tick %s = %s", vm.toString(tickOnBoundary), liqAdded.pretty());
          logTick(tickOnBoundary);
          logPoolState();

        IRouter.ExactInputSingleParams memory forwardsParams = getExactInputSingleParams(1, false);
        router.swapExactInputSingle(forwardsParams);
        logPoolState();
        return getLiquidity();
    }


    /********** HELPERS ***********/

    function logPoolState() internal view {
        (uint160 sqrtP,int24 currentTick,int24 nearestCurrentTick,) = wstETH_ETH.getPoolState();
        (uint128 baseL,,) = wstETH_ETH.getLiquidityState();
        console.log("PoolState {");
        console.log("  sqrtP       = %s", sqrtP);
        console.log("  currentTick = %s", vm.toString(currentTick));
        console.log("  nearestCurrentTick = %s", vm.toString(nearestCurrentTick));
        console.log("  baseL       = %s", baseL.pretty());
        console.log("}");
    }

    function logTick(int24 tick) internal view {
      (uint128 liquidityGross,int128 liquidityNet,,) = wstETH_ETH.ticks(tick);
      console.log("Tick %s {", vm.toString(tick));
      console.log("  liquidityGross = %s", liquidityGross.pretty());
      console.log("  liquidityNet = %s", liquidityNet.pretty());
      console.log("}");
    }

    function ethInUsdc(uint160 price) internal pure returns (uint256) {
        uint256 price_ = uint256(price);
        return 1e18 / ((price_ * price_) >> 192);
    }

    function usdcInEth(uint160 price) internal pure returns (uint256) {
        return (uint256(price) * price) >> 192;
    }

    function getSqrtP() internal view returns (uint160) {
        (uint160 sqrtP,,,) = wstETH_ETH.getPoolState();
        return sqrtP;
    }

    function getCurrentTick() internal view returns (int24) {
        (,int24 currentTick,,) = wstETH_ETH.getPoolState();
        return currentTick;
    }

    function getNearestCurrentTick() internal view returns (int24) {
        (,,int24 nearestCurrentTick,) = wstETH_ETH.getPoolState();
        return nearestCurrentTick;
    }

    function getLiquidity() internal view returns (uint128) {
        (uint128 baseL,,) = wstETH_ETH.getLiquidityState();
        return baseL;
    }

    function setLiquidity(uint128 liquidity) internal {
        setSlotBitRange(BASEL_INDEX, 0, 128, uint256(liquidity));
    }

    function setSqrtP(uint160 sqrtP) internal {
        setSlotBitRange(SQRTP_INDEX, 0, 160, uint256(sqrtP));
    }

    function setCurrentTick(int24 currentTick) internal {
        setSlotBitRange(SQRTP_INDEX, 184, 24, uint256(uint24(currentTick)));
    }

    function setNearestCurrentTick(int24 nearestCurrentTick) internal {
        setSlotBitRange(SQRTP_INDEX, 160, 24, uint256(uint24(nearestCurrentTick)));
    }

    /* TODO: Factor these out into a Foundry extension library */

    function getSlotBitRange(bytes32 slotIndex, uint8 start, uint16 length) internal view returns (uint256) {
        return BitUtils.getBitRange(vm.load(address(wstETH_ETH), slotIndex), start, length);
    }

    function setSlotBitRange(bytes32 slotIndex, uint8 start, uint16 length, uint256 value) internal {
        bytes32 slot = vm.load(address(wstETH_ETH), slotIndex);
        vm.store(address(wstETH_ETH), slotIndex, BitUtils.setBitRange(slot, start,length, value));
    }

    function incSlot(bytes32 slot, uint256 n) internal pure returns (bytes32) {
        return bytes32(uint256(slot) + n);
    }

    function storeOffset(address addr, bytes32 slot, uint256 offset, bytes32 value) internal {
        vm.store(addr, bytes32(uint256(slot) + offset), value);
    }

    function getExactInputSingleParams(uint256 amount, bool zeroForOne) internal view returns (IRouter.ExactInputSingleParams memory) {
        IRouter.ExactInputSingleParams memory params =
          IRouter.ExactInputSingleParams(
            zeroForOne ? wstETH_addr : WETH_addr ,
            zeroForOne ? WETH_addr : wstETH_addr,
            wstETH_ETH.swapFeeUnits(),
            address(this),
            block.timestamp + 86400,
            amount,
            0,
            0
          );
        return params;
    }

}
