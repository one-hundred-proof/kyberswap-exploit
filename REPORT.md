# "Double adding" liquidity bug leads to ability to drain pools at unreasonably good prices

It is possible to get a pool into a state where:
- `sqrtP == TickMath.getSqrtRatioAtTick(tick)` for some `tick`, but
- `poolData.nearestCurrentTick < poolData.tick`

You can then:
- mint liquidity in range `(tick, tick + n)` for some `n`. This will add some liquidity `liq` to `poolData.baseL`
- do a one-for-zero (forward) swap crossing tick `tick` which will add `liq` again to `poolData.baseL`

An attacker can then make a profit by
- bring the price of `token0` down by doing a very large zero-for-one swap (with the aid of a flash loan)
- add sufficient liquidity to drain half of the `token0` balance of the pool
- double add the liquidity to make it sufficient for all of the `token0` balance
- Do a one-for-zero swap to drain all of the `token0` balance. If the price of `token0` is low enough this will require a negligible amount of `token1`.
- The attacker does not need to burn their liquidity since they have already stolen it back for themselves.

## Why is the double-add possible?

Assume `poolData.nearestCurrentTick < pool.currentTick`.

- We mint in range `(pool.currentTick , pool.currentTick + n)` for some `n`.
- `Pool::mint` indirectly calls `_tweakPosition`. The conditions on [Pool.sol:120](https://github.com/KyberNetwork/ks-elastic-sc/blob/362d9b6a726bcb286cc47c082c46f6259a5ae82d/contracts/Pool.sol#L120) and [Pool.sol:137](https://github.com/KyberNetwork/ks-elastic-sc/blob/362d9b6a726bcb286cc47c082c46f6259a5ae82d/contracts/Pool.sol#L137) both evaluate to false. This means that `LiqDeltaMath.applyLiquidityDelta` will be called on [Pool.sol:170](https://github.com/KyberNetwork/ks-elastic-sc/blob/362d9b6a726bcb286cc47c082c46f6259a5ae82d/contracts/Pool.sol#L170)
- We now do a minimal one-for-zero (forward) swap to cross the tick.
  * The problem is that `pool.currentTick == TickMath.getSqrtRatioAtTick(pool.currentTick)` instead of being one unit smaller.
  * Since `pool.nearestCurrentTick < poolData.currentTick` this means that `swapData.nextTick == pool.currentTick` after the call to `_getInitialSwapData(willUpTick)` at [Pool.sol:345-350](https://github.com/KyberNetwork/ks-elastic-sc/blob/362d9b6a726bcb286cc47c082c46f6259a5ae82d/contracts/Pool.sol#L345-L350). This is because [PoolTicksState.sol:145](https://github.com/KyberNetwork/ks-elastic-sc/blob/362d9b6a726bcb286cc47c082c46f6259a5ae82d/contracts/PoolTicksState.sol#L145) is called indirectly.
  ```solidity
  nextTick = poolData.nearestCurrentTick;
  if (willUpTick) {
    nextTick = initializedTicks[nextTick].next;
  }
  ```
  * So the tick to be crossed is `swapData.nextTick == pool.currentTick`. The liquidity that was just added to `pool.baseL` has also been added to the tick data structure at `pool.currentTick.` This means that when  `_updateLiquidityAndCrossTick` is called at [Pool.sol:446-452](https://github.com/KyberNetwork/ks-elastic-sc/blob/362d9b6a726bcb286cc47c082c46f6259a5ae82d/contracts/Pool.sol#L446-L452) the liquidity -- that was just added -- is added again.
- By carefully adding the right amount of extra liquidity an attacker is able to drain all of `token0`.

# Why hasn't this bug happened in practice?

The reason this bug has not occurred in practice is most likely due to the fact that when users call swap functions (e.g. `exactInputSingle`) they did not ever set `limitSqrtP` equal to the `sqrtP` on a tick boundary. Even if they did, they probably didn't realise that by swapping forward and backwards they could set the system up in a state where `poolData.nearestCurrentTick < poolData.currentTick`.

## Executable Proof of Concept

An executable proof of concept has been written in Foundary that exploits the wstETH-ETH pool on Ethereum Mainnet at block height `17050000` (Apr-15-2023 04:13:47 AM +UTC).

Using Aave flashloans the exploit manages to drain approximately 4,556 wstETH and 4,453 WETH from the pool that initial contains 4,570 wstETH and 6,481 WETH respectively.

This is 82.37% of the pool's value.

The initial cost of the attack (before getting a return) is determined by how big the zero-for-one swap is at the beginning that bids down the price.
The bigger the flash loan, the bigger one can make the attack.

For instance if you set `INITIAL_TOKEN0 = 500_000e18` and `TARGET_TICK = -50_000` in the PoC, you'll see that it drains 88% of the pool's value.

## Risk Breakdown

Difficulty to Exploit: Easy
Weakness: Mathematical flaws, logic bugs
CVSS2 Score: Critical
